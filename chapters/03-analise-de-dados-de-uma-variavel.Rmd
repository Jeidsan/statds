# Análise de dados de uma variável

## Introdução

> A ideia de uma análise descritiva de dados é tentar responder as seguintes questões:
>
> i) Qual a frequência com que cada valor (ou intervalo de valores) aparece no conjunto de dados ou seja, qual a distribuição de frequências dos dados?
> ii) Quais são alguns valores típicos do conjunto de dados, como mínimo e máximo?
> iii) Qual seria um valor para representar a posição (ou localização) central do conjunto de dados?
> iv) Qual seria uma medida da variabilidade ou dispersão dos dados?
> v) Existem valores atípicos ou discrepantes (outliers) no conjunto de dados?
> vi) A distribuição de frequências dos dados pode ser considerada simétrica? 
>
> [@MorettinSinger2022, p. 37]

## Distribuição de frequências

Sem notas para esta seção.

## Medidas resumo

> Dado um número $0 < \alpha < 1$, a **média aparada** de ordem $\alpha$, $\overline{x}(\alpha)$, é definida como a média do conjunto de dados obtido após a eliminação das 100% primeiras observações ordenadas e das 100% últimas observações ordenadas do conjunto original [...]. Para $\alpha = 0,25$ obtemos a chamada **meia média**. [@MorettinSinger2022, p. 47]. 

Dado um número natural $k \geq 2$ e um conjunto $X = \{x_{1}, \cdots, x_{n}\}$ com $n \in \mathbb{N}$, o $k$-ésimo **momento centrado** de X é dado por [@MorettinSinger2022, p. 50]:

$$m_{k} = \frac{1}{n}\sum_{i = 1}^{n}(x_{i} - \overline{x})^{k}$$

> Dentre as medidas de assimetria, as mais comuns são:
>
> a) o coeficiente de assimetria de Fisher-Pearson: $$g_{1} = \frac{m_{3}}{m_{2}^{(3/2)}}$$
> b) o coeficiente de assimetria de Fisher-Pearson ajustado: $$\frac{\sqrt{n (n - 1)}}{n - 2} g_{1}$$
> [@MorettinSinger2022, p. 50]


> As principais propriedades desses coeficientes são
>
> i) seu sinal reflete a direção da assimetria (sinal negativo corresponde a assimetria à direita e sinal positivo corresponde a assimetria à esquerda);
> ii) comparam a assimetria dos dados com aquela da distribuição normal, que é simétrica,
> iii) valores mais afastados do zero indicam maiores magnitudes de assimetria e consequente- mente, maior afastamento da distribuição normal;
> iv) a estatística indicada em (3.15) tem um ajuste para o tamanho amostral;
> v) esse ajuste tem pequeno impacto em grandes amostras.
> [@MorettinSinger2022, p. 51]

> Outro coeficiente de assimetria mais intuitivo é o chamado **coeficiente de assimetria de Pearson 2**, estimado por $$Sk_{2} = \frac{3 \cdot [ x - med(x_{1}, \cdots, x_{n})]}{S}$$ [@MorettinSinger2022, p. 51].

> Seja $X$ uma variável aleatória qualquer, com média $\mu$ e variância $\sigma^{2}$. A **curtose** de $X$ é definida por $$K(X) = E \left[ \frac{(X - \mu)^{4}}{\sigma^{4}} \right]$$ [@MorettinSinger2022, p. 53]

## _Boxplots_

Sem notas para esta seção.

## Modelos probabilísticos

Sem notas para esta seção.

## Dados amostrais

Sem notas para esta seção.

## Gráficos QQ

> Uma das questões fundamentais na especificação de um modelo para inferência estatística é a escolha de um modelo probabilístico para representar a distribuição (desconhecida) da variável de interesse na população. Uma possível estratégia para isso é examinar o histograma dos dados amostrais e compará-lo com histogramas teóricos associados a modelos probabilísticos candidatos. Alternativamente, os gráficos QQ (QQ plots) também podem ser utilizados com essa finalidade  [@MorettinSinger2022, p. 59].

## Desvio padrão e erro padrão

Sem notas para esta seção.

## Intervalo de confiança e tamanho da amostra

> [...] **margem de erro**, que, essencialmente, é uma medida de nossa incerteza na extrapolação dos resultados obtidos para a população de onde assumimos que foi obtida  [@MorettinSinger2022, p. 65].

> A margem de erro depende do processo amostral, do desvio padrão amostral $S$, do tamanho da amostra $n$ e é dado por $me = \frac{kS}{\sqrt{n}}$ em que $k$ é uma constante que depende do modelo probabilístico adotado e da confiança com que pretendemos fazer a inferência [@MorettinSinger2022, p. 65].

> Especificamente no caso da estimação da média (populacional) $\mu$ de uma variável $X$, a pergunta seria *Qual é o tamanho da amostra necessário para que a estimativa* $\overline{X}$ *da média* $\mu$ *tenha uma precisão* $\varepsilon$*?* A resposta pode ser obtida da expressão (3.21), fazendo $\varepsilon = \frac{1,96 \cdot S}{\sqrt{n}}$ [@MorettinSinger2022, p. 66].

## Transformação de variáveis

> Se quisermos utilizar os procedimentos talhados para análise de dados com distribuição normal em situações nas quais a distribuição dos dados amostrais é sabidamente assimétrica, pode-se considerar uma transformação das observações com a finalidade de se obter uma distribuição "mais simétrica" e portanto, mais próxima da distribuição normal. Uma transformação bastante usada com esse propósito é 
>
$$
x^{(p)} =
  \begin{cases}
    x^{p}, & se \ p > 0 \\
    log(x), & se \ p = 0 \\
    -x^{p}, & se \ p < 0
  \end{cases}
$$
>
> Essa transformação com $0 < p < 1$ apropriada para distribuições assimétricas à direita, pois valores grandes decrescem de $x$ decrescem mais relativamente a valores pequenos. Para distribuições assimétricas à esquerda, basta tomar $p > 1$. Normalmente, consideramos valores de $p$ na sequência 
>
> $$\cdots, -3, -2, -1, -1/2, -1/3, -1/4, 0, 1/4, 1/3, 1/2, 1, 2, 3, \cdots$$ 
>
> e para cada um deles construímos gráficos apropriados (histogramas, boxplots) com os dados originais transformados, com a finalidade de escolher o valor mais adequado para $p$. Hinkley (1977) sugere que para cada valor de $p$ na sequência acima se calcule a média, a mediana e um estimador de escala (esvio padrão ou algum estimador robusto) e então se escolha o valor que minimiza 
>
>$$d_{p} = \frac{média - mediana}{medida \ de \ escala}$$
>
>[@MorettinSinger2022, p. 67].


> A transformação (3.23) [acima] é um caso particular das **transformações de Box-Cox** que são da forma
>
$$
g(x) = 
  \begin{cases}
    \frac{(x^{p} - 1)}{p}, & se \ p \neq 0 \\
    log(x), & se \ p = 0
  \end{cases}
$$
>
> [@MorettinSinger2022, p. 69].

## Notas de capítulo

Sem notas para esta seção.

## Exercícios

### Exercício 3.1 {- #exr3-1}

::: {.enunciado}
O arquivo `rehabcardio.xls` [@CarvalhoEtAl2007] contém informações sobre um estudo de reabilitação de pacientes cardiacos. Elabore um relatório indicando possíveis inconsistências na matriz de dados e faça uma análise descritiva das variáveis `Peso`, `Altura`, `Coltot`, `HDL`, `LDL`, `Lesoes`, `Diabete` e `HA`. Com essa finalidade,

a) Construa distribuições de frequências para as variáveis qualitativas.
b) Construa histogramas, *boxplots* e gráficos de simetria para as variáveis continuas.
c) Construa uma tabela com medidas resumo para as variáveis continuas.
d) Avalie a compatibilidade de distribuições normais para as variáveis continuas por meio de gráficos QQ.
:::

:::{.solution}

#### Preparação dos dados {-}

Vamos iniciar a nossa análise carregando o arquivo com a biblioteca **readxl**.

```{r}
rehabcardio <- readxl::read_xls(paste0(data_dir, "rehabcardio.xls"))
```

Nosso conjunto de dados contém `r ncol(rehabcardio)` variáveis aferidas em `r nrow(rehabcardio)` pacientes. Vamos avaliar cada variável individualmente e fazer os ajustes necessários. 

As variáveis do conjunto são:

```{r}
colnames(rehabcardio)
```
Um pequeno resumo das variáveis originais é apresentado a seguir:

```{r}
summary(rehabcardio)
```

Vejamos agora os tipos de dados em cada coluna:

```{r}
rehabcardio %>%
  map(typeof) %>%
  as.data.frame() %>%
  t() %>%
  kable(
    format = "pipe",
    caption = "**Tabela 3.1:** Tipos de dados das vatiáveis em `rehabcardio.xls`",
    label = NA,
    digits = 2,
    align = "c",
    format.args = list(decimal.mark = ",")
  )
```

Notamos que há vários tipos inconsistentes. Podemos resolver isso informando os tipos durante o carregamento dos dados ou usando a função `mutate()` em conjunção com as funções de `as.*()` do `R`. Optamos pela segunda forma:

```{r}
rehabcardio <- rehabcardio %>%
                  mutate(
                    Registro = as.integer(Registro),
                    Genero = as.factor(Genero),
                    Origem = as.factor(Origem),
                    Grupo = as.factor(Grupo),
                    Nascimento = as.Date(Nascimento),
                    Coleta = as.Date(Coleta),
                    Programa = as.Date(Programa),
                    Lesoes = as.integer(Lesoes),
                    IAM1 = as.logical(IAM1),
                    RM1 = as.logical(RM1),
                    ATC1 = as.logical(ATC1),
                    Peso = as.double(Peso),
                    Altura = as.double(Altura),
                    Tabagismo = as.logical(Tabagismo),
                    Diabete = as.logical(Diabete),
                    HA = as.logical(HA),
                    Coltot = as.double(Coltot),
                    HDL = as.double(HDL),
                    LDL = as.double(LDL),
                    Triglic = as.double(Triglic),
                    Glicose = as.double(Glicose),
                    Acurico = as.double(Acurico),
                    ColtotHDL = as.double(ColtotHDL),
                    Aspirina = as.logical(Aspirina),
                    Betabloc = as.logical(Betabloc),
                    Nitrato = as.logical(Nitrato),
                    Hipolip = as.logical(Hipolip),
                    IECA = as.logical(IECA),
                    CA = as.logical(CA),
                    Diuretico = as.logical(Diuretico),
                    Digit = as.logical(Digit),
                    Outros = as.logical(Outros),
                    Nummed = as.integer(Nummed),
                    Tempesforco = as.double(Tempesforco),
                    Isquemia = as.logical(Isquemia),
                    RM2 = as.logical(RM2),
                    DataRM2 = as.Date(DataRM2),
                    ATC2 = as.logical(ATC2),
                    DataATC2 = as.Date(DataATC2),
                    IAM2 = as.logical(IAM2),
                    DataIAM2 = as.Date(DataIAM2),
                    Obito = as.Date(Obito),
                    Causa = as.integer(Causa)
                )
```
Antes de seguirmos, vamos salvar nosso conjunto de dados em um novo arquivo para facilitar análises futuras.

```{r}
rehabcardio %>%
  write_csv(paste0(data_dir, "rehabcardio.csv"))
```

Podemos agora seguir com a análise dos dados.

#### Distribuição de frequência para as variáveis qualitativas {-}

As tabela 3.2 e 3.3 a seguir apresentam a distribuição de frequência para as variáveis `Diabete` e `HA`.

```{r}
rehabcardio %>%
  group_by(Diabete) %>%
  summarize(
    `Frequência observada` = n(),
    `Frequência relativa` = 100 * n() / nrow(rehabcardio)
  ) %>%
  mutate(
    `Frequência acumulada` = cumsum(`Frequência relativa`),
    Diabete = case_when(
      Diabete ~ "Presente",
      !Diabete ~ "Ausente",
      is.na(Diabete) ~ "Sem resposta"
    )
  ) %>%
  bind_rows(
    tribble(
      ~Diabete, ~`Frequência observada`, ~`Frequência relativa`,  ~`Frequência acumulada`,
      "**Total**",  nrow(rehabcardio),       100,                     100
    )
  ) %>%
  kable(
    format = "pipe",
    caption = "**Tabela 3.2:** Distribuição de frequência da variável `Diabete`",
    label = NA,
    digits = 2,
    align = "c",
    format.args = list(decimal.mark = ",")
  )

```

```{r}
rehabcardio %>%
  group_by(HA) %>%
  summarize(
    `Frequência observada` = n(),
    `Frequência relativa` = 100 * n() / nrow(rehabcardio)
  ) %>%
  mutate(
    `Frequência acumulada` = cumsum(`Frequência relativa`),
    `Diagnóstico` = case_when(
      HA ~ "Hipertenso",
      !HA ~ "Normotenso",
      is.na(HA) ~ "Sem resposta"
    )
  ) %>%
  bind_rows(
    tribble(
      ~`Diagnóstico`, ~`Frequência observada`, ~`Frequência relativa`,  ~`Frequência acumulada`,
      "**Total**",  nrow(rehabcardio),       100,                     100
    )
  ) %>%
  select(`Diagnóstico`, `Frequência observada`, `Frequência relativa`, `Frequência acumulada`) %>%
  kable(
    format = "pipe",
    caption = "**Tabela 3.3:** Distribuição de frequência da variável `HA`",
    label = NA,
    digits = 2,
    align = "c",
    format.args = list(decimal.mark = ",")
  )

```


#### Histogramas, *boxplots* e gráficos de simetria para as variáveis continuas {-}

```{r}
rehabcardio %>%
  ggplot(aes(x = Peso)) +
    geom_histogram(
      mapping = aes(y = ..density..), 
      binwidth = 6, 
      fill = "grey", 
      color = "grey30"
    ) +
    geom_function(
      fun = dnorm, 
      args = list(
                mean = mean(rehabcardio$Peso, na.rm = TRUE), 
                sd = sd(rehabcardio$Peso, na.rm = TRUE)
              )
    ) +
    labs(
      title = "Figura 3.1: Distribuição de frequência dos pesos dos pacientes",
      x = "Peso (kg)",
      y = "Densidade da frequência"
    ) +
    tema
```

```{r}
rehabcardio %>%
  ggplot(aes(x = Peso)) +
    stat_boxplot(geom = "errorbar", width = 0.2) +
    geom_boxplot(
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.2: Distribuição do peso dos pacientes",
      x = "Peso (kg)"
    ) +
    tema
```


```{r}
geom_symmetry <- function(x) {
    x <- sort(x)
    
    mediana <- median(x)
    n <- length(x)
    meio_n <- (n+1)/2
    
    uv = tibble(
      u = rep(0, meio_n), 
      v = rep(0, meio_n)
    )
    
    for (i in seq(1, meio_n, 1)) {
      uv$u[i] <- mediana - x[i]
      uv$v[i] <- x[n + 1 - i] - mediana
    }  
    
    geom_point(data = uv, mapping = aes(u, v))
}

rehabcardio %>%
  ggplot() +
    geom_symmetry(rehabcardio$Peso) +
    geom_abline(aes(intercept = 0, slope = 1), color = "red", alpha = .5) +
    labs(
      title = "Figura 3.3: Gráfico de simetria para o peso dos pacientes",
      x = "Dispersão inferior",
      y = "Dispersão superior"
    ) +
    tema
```


```{r}
rehabcardio %>%
  ggplot(aes(x = Altura)) +
    geom_histogram(
      mapping = aes(y = ..density..), 
      binwidth = 0.06, 
      fill = "grey", 
      color = "grey30"
    ) +
    geom_function(
      fun = dnorm, 
      args = list(
                mean = mean(rehabcardio$Altura, na.rm = TRUE), 
                sd = sd(rehabcardio$Altura, na.rm = TRUE)
              )
    ) +
    labs(
      title = "Figura 3.4: Distribuição de frequência das alturas dos pacientes",
      x = "Altura (m)",
      y = "Densidade da frequência"
    ) +
    tema 
```
```{r}
rehabcardio %>%
  ggplot(aes(x = Altura)) +
    stat_boxplot(geom = "errorbar", width = 0.2) +
    geom_boxplot(
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.5: Distribuição da altura dos pacientes",
      x = "Altura (m)"
    ) +
    tema
```

```{r}
rehabcardio %>%
  ggplot() +
    geom_symmetry(rehabcardio$Altura) +
    geom_abline(aes(intercept = 0, slope = 1), color = "red", alpha = .5) +
    labs(
      title = "Figura 3.6: Gráfico de simetria para a altura dos pacientes",
      x = "Dispersão inferior",
      y = "Dispersão superior"
    ) +
    tema
```


```{r}
rehabcardio %>%
  ggplot(aes(x = Coltot)) +
    geom_histogram(
      mapping = aes(y = ..density..), 
      binwidth = 20, 
      fill = "grey", 
      color = "grey30"
    ) +
    geom_function(
      fun = dnorm, 
      args = list(
                mean = mean(rehabcardio$Coltot, na.rm = TRUE), 
                sd = sd(rehabcardio$Coltot, na.rm = TRUE)
              )
    ) +
    labs(
      title = "Figura 3.7: Distribuição de frequência do colesterol total dos pacientes",
      x = "Colesterol total (mg/dL)",
      y = "Densidade da frequência"
    ) +
    tema
```
```{r}
rehabcardio %>%
  ggplot(aes(x = Coltot)) +
    stat_boxplot(geom = "errorbar", width = 0.2) +
    geom_boxplot(
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.9: Distribuição do colesterol total dos pacientes",
      x = "Colesterol total (mg/dL)"
    ) +
    tema
```

```{r}
rehabcardio %>%
  ggplot() +
    geom_symmetry(rehabcardio$Coltot) +
    geom_abline(aes(intercept = 0, slope = 1), color = "red", alpha = .5) +    labs(
      title = "Figura 3.10: Gráfico de simetria para os níveis de colesterol total dos pacientes",
      x = "Dispersão inferior",
      y = "Dispersão superior"
    ) +
    tema
```

```{r}
rehabcardio %>%
  ggplot(aes(x = HDL)) +
    geom_histogram(
      mapping = aes(y = ..density..), 
      binwidth = 7, 
      fill = "grey", 
      color = "grey30"
    ) +
    geom_function(
      fun = dnorm, 
      args = list(
                mean = mean(rehabcardio$HDL, na.rm = TRUE), 
                sd = sd(rehabcardio$HDL, na.rm = TRUE)
              )
    ) +
    labs(
      title = "Figura 3.11: Distribuição de frequência do colesterol HDL dos pacientes",
      x = "Colesterol HDL (mg/dL)",
      y = "Densidade da frequência"
    ) +
    tema
```


```{r}
rehabcardio %>%
  ggplot(aes(x = HDL)) +
    stat_boxplot(geom = "errorbar", width = 0.2) +
    geom_boxplot(
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.12: Distribuição do colesterol HDL dos pacientes",
      x = "Colesterol HDL (mg/dL)"
    ) +
    tema
```


```{r}
rehabcardio %>%
  ggplot() +
    geom_symmetry(rehabcardio$HDL) +
    geom_abline(aes(intercept = 0, slope = 1), color = "red", alpha = .5) +
    labs(
      title = "Figura 3.13: Gráfico de simetria para os níveis de colesterol HDL dos pacientes",
      x = "Dispersão inferior",
      y = "Dispersão superior"
    ) +
    tema
```


```{r}
rehabcardio %>%
  ggplot(aes(x = LDL)) +
    geom_histogram(
      mapping = aes(y = ..density..), 
      binwidth = 20, 
      fill = "grey", 
      color = "grey30"
    ) +
    geom_function(
      fun = dnorm, 
      args = list(
                mean = mean(rehabcardio$LDL, na.rm = TRUE), 
                sd = sd(rehabcardio$LDL, na.rm = TRUE)
              )
    ) +
    labs(
      title = "Figura 3.14: Distribuição de frequência do colesterol LDL dos pacientes",
      x = "Colesterol LDL (mg/dL)",
      y = "Densidade da frequência"
    ) +
    tema
```

```{r}
rehabcardio %>%
  ggplot(aes(x = LDL)) +
    stat_boxplot(geom = "errorbar", width = 0.2) +
    geom_boxplot(
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.15: Distribuição do colesterol LDL dos pacientes",
      x = "Colesterol LDL (mg/dL)"
    ) +
    tema
```



```{r}
rehabcardio %>%
  ggplot() +
    geom_symmetry(rehabcardio$LDL)+
    geom_abline(aes(intercept = 0, slope = 1), color = "red", alpha = .5) +
    labs(
      title = "Figura 3.16: Gráfico de simetria para os níveis de colesterol LDL dos pacientes",
      x = "Dispersão inferior",
      y = "Dispersão superior"
    ) +
    tema
```

#### c) Construa uma tabela com medidas resumo para as variáveis continuas {-}

```{r}
summ <- function(x) {
  c(
    n = sum(!is.na(x), na.rm = TRUE),
    `Mínimo` = min(x, na.rm = TRUE),
    Q1 = quantile(x, 0.25, na.rm = TRUE)[[1]],
    `Mediana` = median(x, na.rm = TRUE),
    Q3 = quantile(x, 0.75, na.rm = TRUE)[[1]],
    `Máximo` = max(x, na.rm = TRUE),
    `Média` = mean(x, na.rm = TRUE),
    `Desvio Padrão` = sd(x, na.rm = TRUE),
    `Distância Interquartil` = IQR(x, na.rm = TRUE)
  )
}

resumo <- rehabcardio %>%
            select(Peso, Altura, Coltot, HDL, LDL) %>%
            map(summ) %>%
            as.data.frame() %>%
            t()

resumo %>%
  kable(
    format = "pipe",
    caption = "**Tabela 3.4:** Medidas de resumo para algumas variáveis de `rehabcardio.xls`",
    label = NA,
    digits = 2,
    align = "c",
    format.args = list(decimal.mark = ",")
  )
```


#### d) Avalie a compatibilidade de distribuições normais para as variáveis continuas por meio de gráficos QQ {-}

```{r}
rehabcardio %>%
  ggplot(aes(sample = Peso)) +
    geom_qq() +
    geom_qq_line() +
    labs(
      title = "Figura 3.17: Gráfico QQ normal para o peso dos pacientes",
      x = "Quantis normais",
      y = "Quantis amostrais"
    ) +
    tema
```

```{r}
rehabcardio %>%
  ggplot(aes(sample = Altura)) +
    geom_qq() +
    geom_qq_line() +
    labs(
      title = "Figura 3.18: Gráfico QQ normal para a altura dos pacientes",
      x = "Quantis normais",
      y = "Quantis amostrais"
    ) +
    tema
```

```{r}
rehabcardio %>%
  ggplot(aes(sample = Coltot)) +
    geom_qq() +
    geom_qq_line() +
    labs(
      title = "Figura 3.19: Gráfico QQ normal para os níveis de colesterol total dos pacientes",
      x = "Quantis normais",
      y = "Quantis amostrais"
    ) +
    tema
```

```{r}
rehabcardio %>%
  ggplot(aes(sample = HDL)) +
    geom_qq() +
    geom_qq_line() +
    labs(
      title = "Figura 3.20: Gráfico QQ normal para os níveis de colesterol HDL dos pacientes",
      x = "Quantis normais",
      y = "Quantis amostrais"
    ) +
    tema
```

```{r}
rehabcardio %>%
  ggplot(aes(sample = LDL)) +
    geom_qq() +
    geom_qq_line() +
    labs(
      title = "Figura 3.21: Gráfico QQ normal para os níveis de colesterol LDL dos pacientes",
      x = "Quantis normais",
      y = "Quantis amostrais"
    ) +
    tema
```
:::

### Exercício 3.2 {- #exr3-2}

::: {.enunciado}
Considere os dados do arquivo `antracose.xls`.

a) Construa uma tabela com as medidas de posição e dispersão estudadas para as variáveis desse arquivo.
b) Construa histogramas e boxplots para essas variáveis e verifique que transformação é necessária para tornar mais simétricas aquelas em que a simetria pode ser questionada. 
:::

:::{.solution}
Vamos começar carregando o arquivo.

```{r}
antracose <- readxl::read_xls(paste0(data_dir, "antracose.xls"))
```

#### Construa uma tabela com as medidas de posição e dispersão estudadas para as variáveis desse arquivo {-}

A Tabela 3.5 apresenta as medidas de posição e dispersão dos dados.

```{r}
resumo <- antracose %>%
            map(summ) %>%
            as.data.frame() %>%
            t()

resumo %>%
  kable(
    format = "pipe",
    caption = "**Tabela 3.5:** Medidas de resumo para algumas variáveis de `antracose.xls`",
    label = NA,
    digits = 2,
    align = "c",
    format.args = list(decimal.mark = ",")
  )
```

#### Construa histogramas e boxplots para essas variáveis e verifique que transformação é necessária para tornar mais simétricas aquelas em que a simetria pode ser questionada {-}

Para a variável `idade`, temos o seguinte:

```{r}
antracose %>%
  ggplot(aes(x = idade)) +
    geom_histogram(
      binwidth = 3,
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.22: Distribuição da idade dos pacientes",
      x = "Idade (anos)"
    ) +
    tema
```


```{r}
antracose %>%
  ggplot(aes(x = idade)) +
    stat_boxplot(geom = "errorbar", width = 0.2) +
    geom_boxplot(
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.23: Idade dos pacientes",
      x = "Idade (anos)"
    ) +
    tema
```
Observando os gráficos, podemos perceber uma leve (muito leve) assimetria à esquerda. O coeficiente de simetria de Fisher-Pearson ajustado é negativo (`r e1071::skewness(antracose$idade, type = 2)`), o que indica a leve assimetria.

Entendemos que não seria necessário nenhuma transformação, uma vez que a assimetria é muito leve, porém se usarmos a transformação de Box-Cox, teremos o seguinte:

```{r}
p <- seq(-3,3, 1/10) # c(-3, -2, -1, -1/2, -1/3, -1/4, 0, 1/4, 1/3, 1/2, 1, 2, 3)

transformar <- function(x, p) {
  if(p > 0) {
    x^p
  } else if (p == 0) {
    log(x)
  } else {
    -x^p
  }
}

boxcox <- function(x, p) {
  if(p == 0) {
    log(x)
  } else {
    (((x ^ p) - 1) / p)
  }
}

calcular_metrica <- function(x) {
  x <- x[is.finite(x)]
  (mean(x, na.rm = TRUE) - median(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)
}

dps <- vector("double", length(p))
for (i in seq_along(p)) {
  dps[[i]]  <- antracose$idade %>%
                  transformar(p[i]) %>%
                  calcular_metrica()
}

p[min_rank(dps)[1]]
```
Após a transformação, verificação que o valor que minimiza a nossa métrica de transformação é $p = -1$, que faz a transformação levar $x$ no seu simétrico $-x$. Isso corrobora com a nossa hipótese de que a função já é a mais simétrica possível (nos termos da nossa transformação). 

Para a variável `tmunic`, temos:

```{r}
antracose %>%
  ggplot(aes(x = tmunic)) +
    geom_histogram(
      binwidth = 8,
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.24: Distribuição da variável `tmunic`",
      y = "Frequência"
    ) +
    tema
```

```{r}
antracose %>%
  ggplot(aes(x = tmunic)) +
    stat_boxplot(geom = "errorbar", width = 0.2) +
    geom_boxplot(
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.25: Distribuição da variável `tmunic`"
    ) +
    tema
```
Observando os gráficos, podemos perceber uma leve (muito leve) assimetria à esquerda. O coeficiente de simetria de Fisher-Pearson ajustado é negativo (`r e1071::skewness(antracose$tmunic, type = 2)`), o que indica a leve assimetria.

Podemos usar uma transformação para corrigir a assimetria dos dados:

```{r}
dps <- vector("double", length(p))
for (i in seq_along(p)) {
  dps[[i]]  <- antracose$tmunic %>%
                  boxcox(p[i]) %>%
                  calcular_metrica()
}

p[min_rank(dps)[1]]
```
Notamos que o melhor valor de $p$ é $-1/3$. Com isso, podemos realizar utilizar esta transformação.

```{r}
antracose$tmunic2 <- boxcox(antracose$tmunic, p[min_rank(dps)[1]])

antracose %>%
  ggplot(aes(x = tmunic2)) +
    geom_histogram(
      binwidth = 1,
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.26: Distribuição da variável `tmunic2`",
      y = "Frequência"
    ) +
    tema
```
Neste caso, a transformação não melhorou a simetria dos dados. Em vez disso, o coeficiente de assimetria saltou de `r e1071::skewness(antracose$tmunic, type = 2)` para `r e1071::skewness(antracose$tmunic2, type = 2)`.

Para a variável `htransp`, temos:

```{r}
antracose %>%
  ggplot(aes(x = htransp)) +
    geom_histogram(
      binwidth = 0.5,
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.27: Distribuição da variável `htransp`"
    ) +
    tema
```


```{r}
antracose %>%
  ggplot(aes(x = htransp)) +
    stat_boxplot(geom = "errorbar", width = 0.2) +
    geom_boxplot(
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.28: Distribuição da variável `htransp`"
    ) +
    tema
```
A variável contém uma forte assimetria a direita, conforme atesta também o coeficiente de simetria de Fisher-Pearson ajustado (`r e1071::skewness(antracose$htransp, type = 2)`).

Vamos realizar uma transformação:

```{r}
dps <- vector("double", length(p))
for (i in seq_along(p)) {
  dps[[i]]  <- antracose$htransp %>%
                  boxcox(p[i]) %>%
                  calcular_metrica()
}

p[min_rank(dps)[i]]
```
Para os valores de $p$, o melhor ajuste se dá quando $p = 0.9$, vamos utilizá-lo então!

```{r}
antracose$htransp2 <- boxcox(antracose$htransp, p[min_rank(dps)[i]])

antracose %>%
  ggplot(aes(x = htransp2)) +
    geom_histogram(
      binwidth = .5,
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.29: Distribuição da variável `log(htransp)`"
    ) +
    tema
```
Isso melhora um pouco a simetria dos dados, mas ainda assim não é suficiente. Vamos por exemplo, comparar os valores antes e depois da transformação.

```{r}
e1071::skewness(antracose$htransp, type = 2)
e1071::skewness(antracose$htransp2, type = 2)
```
Vejamos agora a variável `cargatabag`:

```{r}
antracose %>%
  ggplot(aes(x = cargatabag)) +
    geom_histogram(
      binwidth = 15,
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.30: Distribuição da variável `cargatabag`"
    ) +
    tema
```


```{r}
antracose %>%
  ggplot(aes(x = cargatabag)) +
    stat_boxplot(geom = "errorbar", width = 0.2) +
    geom_boxplot(
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.31: Distribuição da variável `cargatabag`"
    ) +
    tema
```

Temos uma distribuição fortemente assimétrica à direita. O Coeficiente de Assimetria de Fisher-Pearson Ajustado nos indica um grau de assimetria na ordem de `r e1071::skewness(antracose$cargatabag, type = 2)`.

Como a distribuição tem um formato exponencial, apostaremos que a transformação que leva $x$ em $log(x)$ seja suficiente para melhorar a distibuição dos dados.

```{r}
antracose %>%
  ggplot(aes(log(cargatabag))) +
    geom_histogram(
      binwidth = .6,
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 32: Distribuição da variável `cargatabag`"
    ) +
    tema
```

Continuamos com assimetria, desta vez à esquerda. Vamos realizar outras transformações e avaliar a nossa métrica.

```{r}
dps <- vector("double", length(p))
for (i in seq_along(p)) {
  dps[[i]]  <- antracose$htransp %>%
                  boxcox(p[i]) %>%
                  calcular_metrica()
}

p[min_rank(dps)[1]]
```
Notamos que para $p = 0.3$, nossa métrica é minimizada. 

```{r}
antracose$cargatabag2 <- transformar(antracose$cargatabag, p[min_rank(dps)[1]])

antracose %>%
  ggplot(aes(x = cargatabag2)) +
    geom_histogram(
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.33: Distribuição da variável `cargatabag`"
    ) +
    tema
```

Note que, os valores continuam concentrados no zero, mas os demais, se distribuem de forma mais simétrica do que antes. É importante destacar que, nem sempre será possível tornar simétrica uma distribuição. Neste caso, deveremos procurar técnicas que não dependam da simetria dos dados.

Analisemos agora a variável `antracose`:

```{r}
antracose %>%
  ggplot(aes(x = antracose)) +
    geom_histogram(
      binwidth = .05,
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.34: Distribuição da variável `antracose`"
    ) +
    tema
```


```{r}
antracose %>%
  ggplot(aes(x = antracose)) +
    stat_boxplot(geom = "errorbar", width = 0.2) +
    geom_boxplot(
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.35: Distribuição da variável `antracose`"
    ) +
    tema
```

Temos uma forte assimetria à direita. O Coeficiente de Assimetria de Fisher-Pearson Ajustado é `r e1071::skewness(antracose$antracose, type = 2)`. Vamos verificar se podemos usar uma transformação nos dados.

```{r}
dps <- vector("double", length(p))
for (i in seq_along(p)) {
  dps[[i]]  <- antracose$antracose %>%
                  boxcox(p[i]) %>%
                  calcular_metrica()
}

p[min_rank(dps)[1]]
```
O valor $p = 0.3$ minimiza a nossa medida de avaliação. Vamos agora plotar os dados transformados e avaliar novamente o coeficiente de assimetria.

```{r}
antracose$antracose2 <- boxcox(antracose$antracose, p[min_rank(dps)[1]])

antracose %>%
  ggplot(aes(x = antracose2)) +
    geom_histogram(
      binwidth = .3,
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.36: Distribuição da variável `antracose`"
    ) +
    tema
```

Parece-nos que os dados se tornaram um pouco mais simétricos, mas nada muito significativo. Talvez valha a pena entender se a concentração dos valores em zero é uma medida real ou se apenas serve para simbolizar, por exemplo, um valor que não pode ser medido devido ao valor de outra variável.

```{r}
e1071::skewness(antracose$antracose, na.rm = TRUE, type = 2)
e1071::skewness(antracose$antracose2, na.rm = TRUE, type = 2)
```

Para a variável `ses`, temos:

```{r}
antracose %>%
  ggplot(aes(x = ses)) +
    geom_histogram(
      binwidth = .2,
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.37: Distribuição da variável `ses`"
    ) +
    tema
```


```{r}
antracose %>%
  ggplot(aes(x = ses)) +
    stat_boxplot(geom = "errorbar", width = 0.2) +
    geom_boxplot(
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.38: Distribuição da variável `ses`"
    ) +
    tema
```

Temos uma leve assimetria à direita. O Coeficiente de Assimetria de Fisher-Pearson Ajustado é `r e1071::skewness(antracose$antracose, na.rm = TRUE, type = 2)`. Vamos verificar se podemos usar uma transformação nos dados.

```{r}
dps <- vector("double", length(p))
for (i in seq_along(p)) {
  dps[[i]]  <- antracose$ses %>%
                  boxcox(p[i]) %>%
                  calcular_metrica()
}

p[min_rank(dps)[1]]
```
O valor $p = 0.4$ minimiza a nossa medida de avaliação. Vamos agora plotar os dados transformados e avaliar novamente o coeficiente de assimetria.

```{r}
antracose$ses2 <- boxcox(antracose$ses, p[min_rank(dps)[1]])

antracose %>%
  ggplot(aes(x = ses2)) +
    geom_histogram(
      binwidth = .6,
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.39: Distribuição da variável `antracose`"
    ) +
    tema
```

Notamos que o histograma se tornou um pouco mais simétrico. Vamos avaliar os valores dos coeficientes de assimetria.


```{r}
e1071::skewness(antracose$ses, na.rm = TRUE, type = 2)
e1071::skewness(antracose$ses2, na.rm = TRUE, type = 2)
```

De fato, a transformação da variável nos trouxe uma melhoria significativa na simetria dos dados. 

Para a variável `densid`:

```{r}
antracose %>%
  ggplot(aes(x = densid)) +
    geom_histogram(
      binwidth = .003,
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.40: Distribuição da variável `densid`"
    ) +
    tema
```


```{r}
antracose %>%
  ggplot(aes(x = densid)) +
    stat_boxplot(geom = "errorbar", width = 0.2) +
    geom_boxplot(
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.41: Distribuição da variável `densid`"
    ) +
    tema
```

A distribuição já nos parece bastante adequada, com coeficiente de assimetria `r e1071::skewness(antracose$densid, na.rm = TRUE, type = 2)`.

```{r}
dps <- vector("double", length(p))
for (i in seq_along(p)) {
  dps[[i]]  <- antracose$densid %>%
                  boxcox(p[i]) %>%
                  calcular_metrica()
}

p[min_rank(dps)[1]]
```
Para os diversos valores de $p$, o que minimiza a nossa métrica é justamente $p = 1$, que nos dá a transformação identidade. Em outras palavras, as transformações com as quais estamos trabalhando, não nos darão melhores resultados. 

Por fim, vamos à variável `distmin`:

```{r}
antracose %>%
  ggplot(aes(x = distmin)) +
    geom_histogram(
      binwidth = 190,
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.42: Distribuição da variável `distmin`"
    ) +
    tema
```


```{r}
antracose %>%
  ggplot(aes(x = distmin)) +
    stat_boxplot(geom = "errorbar", width = 0.2) +
    geom_boxplot(
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.43: Distribuição da variável `distmin`"
    ) +
    tema
```

Temos uma forte assimetria à direita. O Coeficiente de Assimetria de Fisher-Pearson Ajustado é `r e1071::skewness(antracose$distmin, na.rm = TRUE, type = 2)`. Vamos verificar se podemos usar uma transformação nos dados.

```{r}
dps <- vector("double", length(p))
for (i in seq_along(p)) {
  dps[[i]]  <- antracose$distmin %>%
                  boxcox(p[i]) %>%
                  calcular_metrica()
}

p[min_rank(dps)[1]]
```
O valor $p = 0.2$ minimiza a nossa medida de avaliação. Vamos agora plotar os dados transformados e avaliar novamente o coeficiente de assimetria.

```{r}
antracose$distmin2 <- boxcox(antracose$antracose, p[min_rank(dps)[1]])

antracose %>%
  ggplot(aes(x = distmin2)) +
    geom_histogram(
      binwidth = 1,
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.44: Distribuição da variável `antracose`"
    ) +
    tema
```

Notamos uma pequena melhora, porém ainda há uma concentração de dados em torno de um valor inicial. Analisemos o coef. de assimetria antes e depois da transformação.

```{r}
e1071::skewness(antracose$distmin, na.rm = TRUE, type = 2)
e1071::skewness(antracose$distmin2, na.rm = TRUE, type = 2)
```
:::

### Exercício 3.3 {- #exr3-3}

::: {.enunciado}
Considere as variáveis `Peso` e `Altura` de homens do conjunto de dados rehabcardio. Determine o número de classes para os histogramas correspondentes por meio de (3.26) e (3.27) e construa-os.
:::

:::{.solution}
Inicialmente vamos filtrar o conjunto de dados original selecionando apenas os indivíduos do sexo masculino.

```{r}
rehabcardio_h <- rehabcardio %>%
                    filter(Genero == "M")
```

Vamos agora definir as funções `freedman_diaconis` e `sturges` para calcular a amplitude das classes.

```{r}
freedman_diaconis <- function(x) {
  s <- sd(x, na.rm = TRUE)
  n <- length(x)
  
  1.349 * s * ((log(n) / n)^(1/3))
}

sturges <- function(x) {
  r <- range(rehabcardio_h$Peso, na.rm = T)
  w = r[2] - r[1]
  n <- length(x)
  
  w / (1 + 3.322 * log(n))
}
```
Com as funções definidas, podemos construir os histogramas usando essa amplitude de classes.


```{r}
rehabcardio_h %>%
  ggplot(aes(Peso)) +
    geom_histogram(
      binwidth = freedman_diaconis(rehabcardio_h$Peso),
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.45: Distribuição do peso utilizando Freedman-Diaconis"
    ) +
    tema
```

```{r}
rehabcardio_h %>%
  ggplot(aes(Peso)) +
    geom_histogram(
      binwidth = sturges(rehabcardio_h$Peso),
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.46: Distribuição do peso utilizando Sturges"
    ) +
    tema
```

```{r}
rehabcardio_h %>%
  ggplot(aes(Altura)) +
    geom_histogram(
      binwidth = freedman_diaconis(rehabcardio_h$Altura),
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.47: Distribuição da altura utilizando Freedman-Diaconis"
    ) +
    tema
```

```{r}
rehabcardio_h %>%
  ggplot(aes(Altura)) +
    geom_histogram(
      binwidth = sturges(rehabcardio_h$Altura),
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.48: Distribuição da altura utilizando Sturges"
    ) +
    tema
```

:::

### Exercício 3.4 {- #exr3-4}

::: {.enunciado}
Considere o arquivo `vento.xls`. Observe o valor atipico $61,1$, que na realidade ocorreu devido a uma forte tempestade no dia 2 de dezembro. Calcule as medidas de posição e dispersão apresentadas na Seção 3.3. Quantifique o efeito do valor atipico indicado nessas medidas.
:::

:::{.solution}
Em primeiro lugar, carregamos o conjunto de dados:

```{r}
vento <- readxl::read_xls(paste0(data_dir, "vento.xls"))
```

Esboçaremos um gráfico mostrando a velocidade do vento a cada dia.

```{r}
vento %>%
  ggplot(aes(t, vt)) +
    geom_line() +
    geom_point() +
    labs(
      title = "Figura 3.49: Velocidade do vento nos primeiros quinze dias de dezembro",
      x = "Dia",
      y = "Velocidade"
    ) +
    scale_x_continuous(breaks = seq(1, 15, 1)) +
    tema
```

#### Medidas de posição {-}

A média da amostra é `r mean(vento$vt)` e o desvio padrão é `r sd(vento$vt)`. Os quartis da amostras são apresentados abaixo:

```{r}
t1 <- data.frame(
            `Mínimo` = min(vento$vt),
            `Q1` = quantile(vento$vt, 0.25)[[1]],
            `Mediana` = median(vento$vt),
            `Q3` = quantile(vento$vt, 0.75)[[1]],
            `Máximo` = max(vento$vt),
            `Média` = mean(vento$vt),
            `Desvio Padrão` = sd(vento$vt)
          )

vento2 <- vento %>% filter(vt < 60)

t2 <- data.frame(
            `Mínimo` = min(vento2$vt),
            `Q1` = quantile(vento2$vt, 0.25)[[1]],
            `Mediana` = median(vento2$vt),
            `Q3` = quantile(vento2$vt, 0.75)[[1]],
            `Máximo` = max(vento2$vt),
            `Média` = mean(vento2$vt),
            `Desvio Padrão` = sd(vento2$vt)
          )

resumo <- bind_rows(t1, t2, t1 - t2)
row.names(resumo) <- c("Antes", "Depois", "Diferença")

resumo %>%
  kable(
    format = "pipe",
    caption = "**Tabela 3.6:** Medidas de resumo para a velocidade do vento",
    label = NA,
    digits = 2,
    align = "c",
    format.args = list(decimal.mark = ",")
  )
```

Notamos que após remoção do valor atípico, há uma diferença considerável tanto na média, como no desvio padrão. Este caiu pela metade.

:::

### Exercício 3.5 {- #exr3-5}

::: {.enunciado}
Construa gráficos ramo-e-folhas e boxplot para os dados do [Exercício 4](#exr3-4).
:::

:::{.solution}
Para a construção do diagrama de ramos e folhas, utilizamos a função `stem()`.

```{r}
stem(vento$vt, scale = 2, atom = 0.001)
```
:::

### Exercício 3.6 {- #exr3-6}

::: {.enunciado}
Transforme os dados do [Exercicio 4](#exr3-4) por meio de (3.23) com $p = 0, 1/4, 1/3, 1/2, 3/4$ e escolha a melhor alternativa de acordo com a medida $d_{p}$, dada em (3.24).
:::

:::{.solution}
Vamos utilizar as funções `boxcox()` e `calcular_metrica()` criadas anteriomente.

```{r}
p <- c(0,1/4, 1/3, 1/2, 3/4)
dps <- vector("double", length(p))
for (i in seq_along(p)) {
  dps[i] <- vento$vt %>%
              boxcox(p[i]) %>%
              calcular_metrica()
}

p[min_rank(dps)[1]]
```

A melhor opção para a transformação é $p = 0$, logo a transformação é dada pela função `log`.

```{r}
vento %>%
  ggplot(aes(t, boxcox(vt, 0))) +
    geom_line() +
    geom_point() +
    labs(
      title = "Figura 3.50: Velocidade do vento nos primeiros quinze dias de dezembro",
      x = "Dia",
      y = "Velocidade"
    ) +
    scale_x_continuous(breaks = seq(1, 15, 1)) +
    tema
```

```{r}
vento %>%
  ggplot(aes(log(vt))) +
    geom_histogram(
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.51: Distribuição da velocidade do vento",
      x = "Dia",
      y = "Frequência"
    ) +
    scale_x_continuous(breaks = seq(1, 15, 1)) +
    tema
```
:::

### Exercício 3.7 {- #exr3-7}

::: {.enunciado}
Analise a variável `Temperatura` do arquivo `poluicao.xls`.
:::

:::{.solution}

Inicialmente carregaos os dados:

```{r}
poluicao <- readxl::read_xls(paste0(data_dir, "poluicao.xls"))
```

E vamos verificar um resumo das variáveis:

```{r}
summary(poluicao)
```
Temos 120 observações, sendo que a temperatura é dada pela variável `temp` e tem média `r mean(poluicao$temp)` e desvio padrão `r sd(poluicao$temp)`.

```{r}
poluicao %>%
  ggplot(aes(dia, temp)) +
    geom_point() +
    labs(
      title = "Figura 3.52: Variação da temperatura nos primeiros 120 dias do ano",
      x = "Dia",
      y = "Temperatura"
    ) +
    tema
```

```{r}
poluicao %>%
  ggplot(aes(temp)) +
    geom_histogram(
      binwidth = 0.75,
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.53: Distribuição da temperatura",
      x = "Temperatura",
      y = "Frequência"
    ) +
    tema
```

```{r}
poluicao %>%
  ggplot(aes(temp)) +
    stat_boxplot(geom = "errorbar", width = 0.2) +
    geom_boxplot(
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.54: Distribuição da temperatura",
      x = "Temperatura"
    ) +
    tema
```

A distribuição tem uma leve assimetria à esquerda. O coeficiente de Assimetria de Fisher-Pearson Ajustado é `r e1071::skewness(poluicao$temp, type = 2)`

Utilizaremos a transformação de Box-Cox para tentar melhorar a simetria dos dados.

```{r}
p <- seq(-3, 3, 1/10)

dps <- vector("double", length(p))
for (i in seq_along(p)) {
  dps[i] <- poluicao$temp %>%
                boxcox(p[i]) %>%
                calcular_metrica()
}

poluicao$temp2 <- boxcox(poluicao$temp, p[min_rank(dps)[1]])
```

Comparando os coeficientes de assimetria antes e após a transformação:

```{r}
e1071::skewness(poluicao$temp, na.rm = TRUE, type = 2)
e1071::skewness(poluicao$temp2, na.rm = TRUE, type = 2)
```
Notamos que a transformação não melhorou a assimetria do gráfico.

```{r}
poluicao %>%
  ggplot(aes(temp2)) +
    geom_histogram(
      bins = 10,
      fill = "grey", 
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.55: Distribuição da temperatura",
      x = "Temperatura",
      y = "Frequência"
    ) +
    tema
```
:::

### Exercício 3.8 {- #exr3-8}

::: {.enunciado}
Analise a variável `Salário de administradores`, disponível no arquivo `salarios.xls`.
:::

:::{.solution}
Carregando os dados:

```{r}
salarios <- readxl::read_xls(paste0(data_dir, "salarios.xls"), skip = 4)
```

O conjunto de dados contém valores de salários para quatro profissões (Profissional de Segurança, Mecânico, Administrador e Engenheiro Eletricista) em trinta cidades ao redor do mundo. 

Vamos fazer uma transformação nos dados para facilitar a visualização:

```{r}
salario2 <- salarios %>%
              gather(key = "Profissao", value = "Salario", -"Cidade")
```

Agora vamos visualizar os salários por profissão:

```{r}
salario2 %>%
  group_by(Profissao) %>%
  summarise(
    Media = mean(Salario)
  ) %>%
  ggplot(aes(x = Profissao, y = Media)) +
    geom_col(
      fill = "grey", 
      color = "grey30"
    ) +
    geom_label(aes(x = Profissao, y = Media, label = format(round(Media, 2), decimal.mark = ",", big.mark = "."))) +
    labs(
      title = "Figura 3.56: Salário médio por profissão",
      x = "Profissão",
      y = "Salário"
    ) +
    tema
```


```{r}
salario2 %>%
  ggplot(aes(Profissao, Salario, group = Profissao)) +
    geom_boxplot(
      fill = "grey", 
      color = "grey30",
    ) +
    labs(
      title = "Figura 3.57: Distribuição dos salários por profissão",
      x = "Profissão",
      y = "Salário"
    ) +
    tema
```

A média geral dos salários é `r format(round(mean(salario2$Salario), 2), decimal.mark = ",", big.mark = ".")` e o desvio padrão é `r format(round(sd(salario2$Salario), 2), decimal.mark = ",", big.mark = ".")`.

Agora vamos focar apenas nos administradores. A distribuição dos salários por cidade é mostrada no gráfico a seguir:

```{r}
order <- arrange(salarios, Administrador)$Cidade

salarios %>%
  ggplot(aes(Cidade, Administrador)) +
    geom_col(
      fill = "grey", 
      color = "grey30",
    ) +
    coord_flip() +
    scale_x_discrete(limits = order) +
    labs(
      title = "Figura 3.58: Distribuição dos salários por profissão",
      x = "Profissão",
      y = "Salário"
    ) +
    tema
    
```

A média salarial dos administradores é `r format(round(mean(salarios$Administrador), 2), decimal.mark = ",", big.mark = ".")`, o desvio padrão é `r format(round(sd(salarios$Administrador), 2), decimal.mark = ",", big.mark = ".")` e a mediana é `r format(round(median(salarios$Administrador), 2), decimal.mark = ",", big.mark = ".")`.

:::

### Exercício 3.9 {- #exr3-9}

::: {.enunciado}
Construa um gráfico ramo-e-folhas e um *boxplot* para os dados de precipitação atmosférica de Fortaleza disponíveis no arquivo `precipitacao.xls`.
:::

:::{.solution}
Carregamos os dados com a função `readxls` do pacote **readxl**:

```{r}
precipitacao <- readxl::read_xls(paste0(data_dir,"precipitacao.xls"))
```
Como os dados estão mal organizados na planilha, precisamos fazer um ajuste.

```{r}
a <- precipitacao %>%
        select(Ano...1, Chuva...2)

b <- precipitacao %>%
        select(Ano...3, Chuva...4)

c <- precipitacao %>%
        select(Ano...5, Chuva...6)

d <- precipitacao %>%
        select(Ano...7, Chuva...8)

precipitacao <- bind_rows(a, b, c, d) %>% drop_na()
```
Utilizamos a função `stem()` para construir o diagrama de ramos e folhas:

```{r}
stem(precipitacao$Chuva)
```
Utilizamos **ggplot2** para construir o boxplot.

```{r}
precipitacao %>%
  ggplot(aes(Chuva)) +
    stat_boxplot(geom = "errorbar", width = 0.2) +
    geom_boxplot(
      fill = "grey", 
      color = "grey30",
    ) +
    labs(
      title = "Figura 3.59: Precipitação atmosférica em Fortaleza-CE",
      x = "Chuva"
    ) +
    tema
```
Salvamos o conjunto de dados para futuras análises:

```{r}
write_csv(precipitacao, paste0(data_dir, "precipitacao.csv"))
```

:::

### Exercício 3.10 {- #exr3-10}

::: {.enunciado}
Construa gráficos de quantis e de simetria para os dados de arquivo manchas solares disponíveis no arquivo `manchas.xls`.
:::

:::{.solution}
Carregamos os dados com **readxl**:

```{r}
manchas <- readxl::read_xls(paste0(data_dir, "manchas.xls"), skip = 4)

a <- manchas %>% select(Ano...1, Número...2)
b <- manchas %>% select(Ano...3, Número...4)
c <- manchas %>% select(Ano...5, Número...6)
d <- manchas %>% select(Ano...7, Número...8)

manchas <- bind_rows(a, b, c, d) %>% drop_na()
```
Agora vamos construir o gráfico que quantis:

```{r}
p <- seq(0, 1, 0.02)
q <- quantile(manchas$Número, p)

data.frame(p, q) %>%
  ggplot(aes(p, q)) +
    geom_point() +
    geom_vline(aes(xintercept = 0.5)) +
    labs(
      title = "Figura 3.60: Quantis para o número de manchas solares",
      x = "p",
      y = "Quantis amostrais"
    ) +
    tema
```

Para o gráfico de simetria (dispersão), temos o seguinte:

```{r}
manchas %>%
  ggplot() +
    geom_symmetry(manchas$Número) +
    geom_abline(aes(intercept = 0, slope = 1), color = "red", alpha = .5) +
    labs(
      title = "Figura 3.61: Gráfico de simetria para o número de manchas solares",
      x = "Dispersão inferior",
      y = "Dispersão superior"
    ) +
    tema
```
Os gráficos acima nos dão uma indicação de vele assimetria à direita. O que pode ser verificado com o Coef. de Assimetria de Fisher-Pearson Ajustado `r e1071::skewness(manchas$Número, type = 2)`.

:::

### Exercício 3.11 {- #exr3-11}

::: {.enunciado}
Uma outra medida de assimetria é $$ A = \frac{(Q_{3} - Q_{2}) - (Q_{2} - Q_{1})}{Q_{3} - Q_{1}},$$ que é iual a zero no caso de distribuições simétricas. Calcule-a para os dados do [Exercício 3.4](#exr3-4).
:::

:::{.solution}
Primeiro vamos definir uma função para calcular a medida.

```{r}
assimetria <- function(x) {
  q <- quantile(x, c(0.25, 0.5, 0.75))
  
  ((q[[3]] - q[[2]]) - (q[[2]] - q[[1]]))/(q[[3]] - q[[1]])
}
```

Usando essa função, temos que o coeficiente de assimetria para a variável `vt` do conjunto `vento.xls` é de `r assimetria(vento$vt)`.


:::

### Exercício 3.12 {- #exr3-12}

::: {.enunciado}
Os dados disponíveis no arquivo `endometrione.xls` [@AbraoEtAl1997] são provenientes de um estudo em que o objetivo é verificar se existe diferença entre os grupos de doentes e controles quanto a algumas caracteristicas observadas.

a) O pesquisador responsável pelo estudo tem a seguinte pergunta: pacientes doentes apresentam mais dor na menstruação do que as pacientes não doentes? Que tipo de análise você faria para responder essa pergunta utilizando as técnicas discutidas neste capitulo? Faça-a e tire suas conclusões.
b) Compare as distribuições das variáveis idade e concentração de PCR durante a menstruação (`PCRa`) para pacientes dos grupos controle e doente utilizando medidas resumo (minimo, máximo, quartis, mediana, média, desvio padrão, etc.), *boxplots*, histogramas, gráficos de médias e gráficos QQ. Como você considerou os valores $< 0,5$ da variável `PCRa` nesses cálculos? Você sugeriria uma outra maneira para considerar tais valores?
c) Compare a distribuição da variável número de gestações para os dois grupos por intermédio de uma tabela de frequências. Utilize um método gráfico para representá-la.
:::

:::{.solution}

Como sempre, vamos iniciar com o carregamento e ajuste nos dados:

```{r}
endometriose <- readxl::read_xls(paste0(data_dir, "endometriose.xls"), sheet = "dados")

head(endometriose, 10)
```

Vamos transformar em fator as variáveis `Grupo`, `Dismenorréia` e `Dispareunia`. Vamos também ubstituir o valor `<0,5` por zero nas variáveis `CA125/A`, `CA125/B`, `PCRa` e `PCRb`. Por fim, transformaremos em inteiras as variáveis `Idade`, `Gestação`, `Partos`, `Abortos` e `AFSr`.

```{r}
dismenorreia_levels <- c("Não tem", "Leve", "Moderada", "Intensa", "Sem informação")
dismenorreia <- function(x) {
  x %>% 
    str_replace("S/", "Sem informação") %>%
    str_replace("N", "Não tem") %>%
    str_replace("L", "Leve") %>%
    str_replace("M", "Moderada") %>% 
    str_replace("I", "Intensa")
}

dispareunia <- function(x) {
  x %>%
    str_replace("\\.", "Sem informação") %>%
    str_replace("N", "Não tem") %>%
    str_replace("P\\b", "Penetração") %>%
    str_replace("PRO", "Profunda") %>%
    str_replace("2", "Penetração e Profunda")
}

zerar <- function(x) {
  x %>%
    str_replace("<0,5", "0")
}

endometriose <- endometriose %>%
                  mutate(
                    Grupo = parse_factor(Grupo),
                    Dismenorréia = parse_factor(dismenorreia(Dismenorréia), levels = dismenorreia_levels, ordered = TRUE),
                    Dispareunia = parse_factor(dispareunia(Dispareunia)),
                    `CA125/A` = parse_double(zerar(`CA125/A`)),
                    `CA125/B` = parse_double(zerar(`CA125/B`)),
                    PCRa = parse_double(zerar(PCRa)),
                    PCRb = parse_double(zerar(PCRb)),
                    Idade = as.integer(Idade),
                    Gestação = as.integer(Gestação),
                    Partos = as.integer(Partos),
                    Abortos = as.integer(Abortos),
                    AFSr = as.integer(AFSr)
                  )

```


#### Pacientes doentes apresentam mais dor na menstruação do que as pacientes não doentes? {-}

Em primeiro lugar, vamos construir uma tabela de contigência com os graus de dismenorréia entre os grupos.

```{r}
endometriose %>%
  group_by(Dismenorréia, Grupo) %>%
  count() %>%
  spread(Grupo, n) %>%
  kable(
    format = "pipe",
    caption = "**Tabela 3.7:** Distribuição da ocorrência de dismenorréia entre casos e controles",
    label = NA,
    digits = 2,
    align = "c",
    format.args = list(decimal.mark = ","),
  )
```

Através da Tabela 3.7, é possível perceber que 88,57% das pacientes com endometriose apresentam dor moderada ou intensa, contra apenas 6,67% das pacientes que não apresentam esta condição. Ou seja, as pacientes com a doença apresentam mais dor na mestruação do que as demais.

#### Distribuição das variáveis `Idade` e `PCRa` entre os grupos {-}

Primeiro vamos calcular as medidas globais de resumo para cada uma das variáveis.

```{r}
endometriose %>%
  select(Idade, PCRa) %>%
  map(summ) %>%
  as.data.frame() %>%
  t() %>%
  kable(
    format = "pipe",
    caption = "**Tabela 3.8:** Medidas de resumo para as variáveis `Idade` e `PCRa`",
    label = NA,
    digits = 2,
    align = "c",
    format.args = list(decimal.mark = ",")
  )
```

Para o grupo de controle, temos o seguinte:

```{r}
endometriose %>%
  filter(Grupo == "Controle") %>%
  select(Idade, PCRa) %>%
  map(summ) %>%
  as.data.frame() %>%
  t() %>%
  kable(
    format = "pipe",
    caption = "**Tabela 3.9:** Medidas de resumo para o grupo de controle",
    label = NA,
    digits = 2,
    align = "c",
    format.args = list(decimal.mark = ",")
  )
```

Para o grupo de casos, obtemos as seguintes medidas:

```{r}
endometriose %>%
  filter(Grupo == "Doente") %>%
  select(Idade, PCRa) %>%
  map(summ) %>%
  as.data.frame() %>%
  t() %>%
  kable(
    format = "pipe",
    caption = "**Tabela 3.10:** Medidas de resumo para o grupo de casos",
    label = NA,
    digits = 2,
    align = "c",
    format.args = list(decimal.mark = ",")
  )
```

Vamos também construir alguns gráficos para visualizar melhor os dados:

```{r}
endometriose %>%
  ggplot(aes(Idade)) +
    geom_histogram(
      binwidth = 4,
      fill = "grey",
      color = "grey30"
    ) +
    facet_wrap(~Grupo) +
    labs(
      title = "Figura 3.62: Distribuição da idade entre pacientes",
      x = "Idade",
      y = "Quantidade"
    ) +
    tema
```

```{r}
endometriose %>%
  ggplot(aes(Grupo, Idade)) +
    stat_boxplot(
      geom = "errorbar",
      width = 0.2
    ) +
    geom_boxplot(
      fill = "grey",
      color = "grey30"
    ) +
    labs(
      title = "Figura 3.63: Distribuição da idade entre pacientes",
      y = "Quantidade"
    ) +
    tema
```


```{r}
endometriose %>%
  ggplot(aes(PCRa)) +
    geom_histogram(
      binwidth = 4,
      fill = "grey",
      color = "grey30"
    ) +
    facet_wrap(~Grupo) +
    labs(
      title = "Figura 3.64: Distribuição da variável `PCRa` entre pacientes",
      x = "PCRa",
      y = "Quantidade"
    ) +
    tema
```

```{r}
endometriose %>%
  ggplot(aes(Grupo, PCRa)) +
    stat_boxplot(
      geom = "errorbar",
      width = 0.2
    ) +
    geom_boxplot(
      fill = "grey",
      color = "grey30"
    ) +
    labs(
      title = bquote(bold("Figura 3.65:")~"Distribuição da variável `PCRa` entre pacientes"),
      y = "Quantidade"
    ) +
    tema
```

Notamos com esses dados que a idade das pacientes com endrometriose varia de 20 a 43 anos, com média de 30,71 anos e desvio padrão de 5,98 anos. Já entre o grupo de controle, a variação de idade é menos (entre 26 e 41 anos), com média de 35,13 anos e desvio padrão de 3,80 anos.

Para a variável PCRa, temos uma discrepância considerável. Mulheres com endometriose tem uma concentração de mais de 6 vezes maior de PCR durante a menstruação do que as pacientes do grupo de controle. 

Optamos por zerar o valor das observações cuja medida foi $ < 0,5$. Uma vez que 0,5 é o menor valor que o instrumento de aferição consegue detectar, entendemos ser justo considerar essas medidas como nula. Seria uma opção desconsiderar essas medidas? Cabe avaliar.


#### Comparando o número de gestações entre os grupos {-}

```{r}
endometriose %>%
  group_by(Grupo, Gestação) %>%
  count() %>%
  pivot_wider(names_from = Grupo, values_from = n, values_fill = 0) %>%
  arrange(Gestação)
```

Vamos também representar graficamente a relação entre os grupos usando um *boxplot*.

```{r}
endometriose %>%
  ggplot(aes(x = Grupo, y = Gestação)) +
    stat_boxplot(
      geom = "errorbar",
      width = 0.2
    ) +
    geom_boxplot(
      fill = "grey",
      color = "grey30"
    ) +
    labs(
      title = bquote(bold("Figura 3.66:")~"Número de gestações entre mulheres com e sem endometriose"),
      x = "Grupo",
      y = "Número de gestações"
    ) +
    tema
```

Notamos que o número de gestações entre mulheres com endometriose é muito menor do que entre as mulheres do grupo controle. Uma parte desse efeito poderia ser explicado pela idade das pacientes (a média de idade das pacientes com endometriose é menor do que as do grupo de controle), mas certamente a doença em si é o maior fator pra o menor número de gestações.

:::

### Exercício 3.13 {- #exr3-13}

::: {.enunciado}
Os dados encontrados no arquivo `enforco.xls` [@Braga1998] são provenientes de um estudo sobre teste de esforço cardiopulmonar em pacientes com insuficiência cardíaca. As variáveis medidas durante a realização do teste foram observadas em quatro momentos distintos: repouso (REP), limiar anaeróbico (LAN), ponto de compensação respiratório (PCR) e pico (PICO). As demais variáveis são referentes às características demográficas e clinicas dos pacientes e foram registras uma única vez.

a) Descreva a distribuição da variável consumo de oxigênio (`VO2`) em cada um dos quatro momentos de avaliação utilizando medidas resumo (mínimo, máximo, quartis, mediana, média, desvio padrão, etc.), *boxplots* e histogramas. Você identifica algum paciente com valores de consumo de oxigênio discrepantes? Interprete os resultados.
b) Descreva a distribuição da classe funcional NYHA por meio de uma tabela de frequências. Utilize um método gráfico para representar essa tabela.
:::

:::{.solution}
#### Preparação dos dados {-}

Iniciaremos carregando os dados e ajustando os nomes das colunas. 

```{r, results = "hide", message = FALSE}
esforco <- readxl::read_xls(paste0(data_dir, "esforco.xls"), sheet = "dados", skip = 3, col_names = FALSE)
colnames(esforco) <- c(
                        "id_grupo", "iniciais", "etiologia", "sexo", "data_espirometrico",
                        "idade", "altura", "peso", "superficie_corporal", "imc",
                        "nyha", "weber", "fc_rep", "vo2_rep", "rer_rep", "vo2_fc_rep",
                        "ve_vo2_rep", "ve_vco2_rep", "aumento_carga_rep", "teste_maximo_rep",
                        "carga_lan", "perc_max_carga_lan", "fc_lan", "vo2_lan", 
                        "perc_max_vo2_lan", "rer_lan", "perc_max_rer_lan", "vo2_fc_lan",
                        "perc_max_vo2_fc_lan", "ve_vo2_lan", "perc_max_ve_vo2_lan",
                        "ve_vco2_lan", "perc_max_ve_vco2_lan", "carga_pcr", "perc_max_carga_pcr",
                        "fc_pcr", "vo2_pcr", "perc_max_vo2_pcr", "rer_pcr", "perc_max_rer_pcr",
                        "vo2_fc_pcr", "perc_max_vo2_fc_pcr", "ve_vo2_pcr", "perc_max_ve_vo2_pcr",
                        "ve_vco2_pcr", "perc_max_ve_vco2_pcr", "carga_w", "fc_w",
                        "vo2_w", "rer_w", "vo2_fc_w", "ve_vo2_w", "ve_vco2_w",
                        "tempo_rampa", "vo2_wr_slope", "ve_vco2_slope", "data_obito", 
                        "data_ultima_obs", "cirurgia"
                      )
```

Vamos também criar algumas funções que nos ajudarão a ajustar os dados.

```{r}
map_etiologia <- function(x) {
  x %>% 
    str_replace("CH\\b", "Chagasíaco") %>%
    str_replace("ID\\b", "Idiopático") %>%
    str_replace("IS\\b", "Isquêmico") %>%
    str_replace("C\\b", "Controle")
}

map_sexo <- function(x) {
  x %>%
    str_replace("M", "Masculino") %>%
    str_replace("F", "Feminino")
}

map_sim_nao_na <- function(x) {
  x %>%
    str_replace("S", "Sim") %>%
    str_replace("N", "Não") %>%
    str_replace("\\.", NA_character_)
}
```

Agora vamos aos ajustes:

```{r}
esforco <- esforco %>%
              mutate(
                id = ifelse(etiologia == 'C', id_grupo + 87, id_grupo),
                grupo = parse_factor(ifelse(etiologia == 'C', "Controle", "Caso")),
                id_grupo = as.integer(id_grupo),
                etiologia = parse_factor(map_etiologia(etiologia)),
                sexo = parse_factor(map_sexo(sexo)),
                data_espirometrico = dmy(data_espirometrico),
                idade = as.integer(idade),
                altura = as.integer(altura),
                nyha = parse_factor(as.character(nyha), levels = c("1", "2", "3", "4"), ordered = TRUE, na = "0"),
                weber = parse_factor(weber, levels = c("A", "B", "C", "D", "E", NA), ordered = TRUE),
                teste_maximo_rep = parse_factor(map_sim_nao_na(teste_maximo_rep)),
                carga_lan = parse_integer(carga_lan, na = "."),
                perc_max_carga_lan = parse_double(perc_max_carga_lan, na = "."),
                fc_lan = parse_double(fc_lan, na = "."),
                vo2_lan = parse_double(vo2_lan, na = "."),
                perc_max_vo2_lan = parse_double(perc_max_vo2_lan, na = "."),
                rer_lan = parse_double(rer_lan, na = "."),
                perc_max_rer_lan = parse_double(perc_max_rer_lan, na = "."),
                vo2_fc_lan = parse_double(vo2_fc_lan, na = "."),
                perc_max_vo2_fc_lan = parse_double(perc_max_vo2_fc_lan, na = "."),
                ve_vo2_lan = parse_double(ve_vo2_lan, na = "."),
                perc_max_ve_vo2_lan = parse_double(perc_max_ve_vo2_lan, na = "."),
                ve_vco2_lan = parse_double(ve_vco2_lan, na = "."),
                perc_max_ve_vco2_lan = parse_double(perc_max_ve_vco2_lan, na = "."),
                carga_pcr = parse_double(carga_pcr, na = "."),
                perc_max_carga_pcr = parse_double(perc_max_carga_pcr, na = "."),
                fc_pcr = parse_double(fc_pcr, na = "."),
                vo2_pcr = parse_double(vo2_pcr, na = "."),
                perc_max_vo2_pcr = parse_double(perc_max_vo2_pcr, na = "."),
                rer_pcr = parse_double(rer_pcr, na = "."),
                perc_max_rer_pcr = parse_double(perc_max_rer_pcr, na = "."),
                vo2_fc_pcr = parse_double(vo2_fc_pcr, na = "."),
                perc_max_vo2_fc_pcr = parse_double(perc_max_vo2_fc_pcr, na = "."),
                ve_vo2_pcr = parse_double(ve_vo2_pcr, na = "."),
                perc_max_ve_vo2_pcr = parse_double(perc_max_ve_vo2_pcr, na = "."),
                ve_vco2_pcr = parse_double(ve_vco2_pcr, na = "."),
                perc_max_ve_vco2_pcr = parse_double(perc_max_ve_vco2_pcr, na = "."),
                carga_w = parse_double(carga_w, na = "."),
                tempo_rampa  = parse_double(tempo_rampa, na = "."),
                vo2_wr_slope  = parse_double(vo2_wr_slope, na = "."),
                data_obito = dmy(data_obito),
                data_ultima_obs = dmy(data_ultima_obs)
              )
```

Com o arquivo organizado, vamos salvá-lo para uso futuro como `esforco_completo.csv`.

```{r}
write_csv(esforco, paste0(data_dir, "esforco_completo.csv"))
```

#### Consumo de oxigênio nos quatro momentos {-}

Inicialmente precisamos destacar que as variáveis de interesse são `vo2_rep`, `vo2_lan`, `vo2_pcr` e `vo2_w`. Vamos isolar essas variáveis e utilizar a função `gather()` para reunir os dados dos momentos em um formato mais amigável.

```{r}
vo2 <- esforco %>%
          select(id, grupo, vo2_rep, vo2_lan, vo2_pcr, vo2_w) %>%
          gather(vo2_rep, vo2_lan, vo2_pcr, vo2_w, key = "Momento", value = "vo2") %>%
          mutate (
            Momento = Momento %>% 
                        str_replace("vo2_rep", "Repouso") %>%
                        str_replace("vo2_lan", "Limiar anaeróbico") %>%
                        str_replace("vo2_pcr", "Ponto de Compensação") %>%
                        str_replace("vo2_w", "Pico")
         )
  
head(vo2)
```

Agora vamos avaliar a disbtibuição da variável `vo2` em cada um dos momentos:

```{r}
vo2 %>%
  ggplot(aes(vo2)) +
    geom_histogram(
      fill = "grey",
      color = "grey30"
    ) +
    facet_wrap(~Momento) +
    labs(
      title = bquote(bold("Figura 3.67:")~"Consumo de oxigênio durante teste de esforço"),
      x = "Consumo de oxigênio - ml/(kg.min)",
      y = "Frequência"
    ) +
    tema
```

```{r}
vo2 %>%
  ggplot(aes(
      x = factor(Momento, level = c("Repouso", "Limiar anaeróbico", "Ponto de Compensação", "Pico")), 
      y = vo2
  )) +
    stat_boxplot(
      geom = "errorbar", 
      width = 0.2
    ) +
    geom_boxplot(
      fill = "grey",
      color = "grey30"
    ) +
    labs(
      title = bquote(bold("Figura 3.68:")~"Consumo de oxigênio durante teste de esforço"),
      x = "Momento do teste",
      y = "Consumo de oxigênio - ml/(kg.min)"
    ) +
    tema
```

Vamos calcular também a média e desvio padrão para o consumo de oxigênio em cada momento:

```{r}
resumo <- vo2 %>%
            group_by(Momento, grupo) %>%
            summarise(
              `Média` = mean(vo2, na.rm = TRUE),
              `Desvio Padrão` = sd(vo2, na.rm = TRUE),
              Q1 = quantile(vo2, 0.25, na.rm = TRUE)[[1]],
              `Mediana` = median(vo2, na.rm = TRUE),
              Q3 = quantile(vo2, 0.75, na.rm = TRUE)[[1]],
              `Distância Interquartil` = IQR(vo2, na.rm = TRUE)
            ) %>%
            arrange(factor(Momento, level = c("Repouso", "Limiar anaeróbico", "Ponto de Compensação", "Pico")))

resumo %>%
  kable(
    format = "pipe",
    caption = "**Tabela 3.11:** Consumo de oxigênio por momento de avaliação",
    label = NA,
    digits = 2,
    align = "c",
    format.args = list(decimal.mark = ",")
  )
```

Os gráficos nos mostram que alguns pacientes possuem um consumo excessivamente alto de oxigênio. Apesar desses valores, os dados parecem apresentar tendência normal. Notamos ainda uma menor consumo de oxigênio para o grupo de pacientes com alguma doença pré-existente.

Abaixo, listamos os identificadores dos valores discrepantes.

```{r}
resumo2 <- resumo %>%
            transmute(
              m = Momento,
              l = Q3 + 1.5 * `Distância Interquartil`
            )

vo2 %>%
  left_join(resumo2, by = join_by(Momento == m)) %>%
  filter(vo2 > l) %>%
  select(id) %>%
  distinct() %>%
  array()
```

#### Observação {-}

Para melhorar a análise, poderíamos montar gráficos separados para casos e controles. Isso facilitaria a comparação entre os dois grupos em cada etapa.

:::

### Exercício 3.14 {- #exr3-14}

::: {.enunciado}
Na tabela abaixo estão indicadas as durações de 335 lâmpadas.

Duração (horas)  | Número de lâmpadas
:---------------:|:------------------:
$0 \vdash 100$   | 82
$100 \vdash 200$ | 71
$200 \vdash 300$ | 68
$300 \vdash 400$ | 56
$400 \vdash 500$ | 43
$500 \vdash 800$ | 15
: **Tabela 3.12:** Duração de 335 lâmpadas

a) Esboce o histograma correspondente.
b) Calcule os quantis de ordem $p = 0,1, 0,3, 0,5, 0,7$ e $0,9$.
:::

:::{.solution}
Vamos começar colocando os dados da tabela em um data frame.

```{r}
lampadas <- tribble(
  ~min, ~max, ~freq,
  0, 99, 82,
  100, 199, 71,
  200, 299, 68,
  300, 399, 56,
  400, 499, 43,
  500, 599, 15
)
```

Vamos agora adicionar a frequência relativa e a frequência acumulada ao nosso data frame:

```{r}
lampadas <- lampadas %>%
                mutate(
                  freq_acu = cumsum(freq),
                  freq_rel = freq/sum(freq),
                  freq_rel_acu = cumsum(freq_rel)
                )

lampadas
```

Com os dados organizados podemos construir o histograma:

```{r}
lampadas %>%
  ggplot(aes(x = min + 50, y = freq)) +
    geom_col(
      fill = "grey",
      color = "grey30"
    ) +
    scale_x_continuous(
      breaks = seq(0, 600, 100)
    ) +
    labs(
      title = bquote(bold("Figura 3.69:")~"Tempo de vida das lâmpadas"),
      x = "Tempo de vida (h)",
      y = "Frequência observada"
    ) +
    tema
```
Para calcular o quantil de ordem $p$, vamos seguir dois passos:

1. utilizar a tabela de frequência para identificar a classe $k$ à qual pertence o quantil de ordem $p$;
2. utilizar a fomula $$ Q_{p} = l_{k} + \frac{( p \cdot n - F_{k-1} ) \cdot h_{k}}{f_{k}} $$ onde:
  a. $l_{i}$ é o limite inferior da classe $i$;
  b. $f_{i}$ é a frequência absoluta da classe $i$;
  c. $F_{i}$ é a frequência acumulada até a classe $i$;
  c. $h_{i}$ é a amplitude da classe $i$;
  d. $n$ é o tamanho da amostra;

Vamos definir uma função para calcular o quantil:

```{r}
quantil <- function(l, p, n, f_p, f_ant, h) {
  l + (((p * n) - f_ant) * (h / f_p))
}
```

Agora temos condições de calcular os quantis:

```{r}
n <- sum(lampadas$freq)
h <- 100

tibble(
  p = c(.1, .3, .5, .7, .9),
  l = c(0, 100, 200, 300, 400),
  f_p = c(82, 71, 68, 56, 43),
  f_ant = c(0, 82, 153, 221, 277)
) %>%
  mutate(
    Q_p = quantil(l, p, n, f_p, f_ant, h)
  ) %>%
  select(p, Q_p) %>%
  kable(
    format = "pipe",
    caption = "**Tabela 3.12:** Quantis para a vida útil de lâmpadas",
    label = NA,
    digits = 2,
    align = "c",
    format.args = list(decimal.mark = ",")
  )
```





:::

### Exercício 3.15 {- #exr3-15}

::: {.enunciado}
Os dados apresentados na tabela abaixo referem-se aos instantes nos quais o centro de controle operacional de estradas rodoviárias recebeu chamados solicitando algum tipo de auxilio em duas estradas num determinado dia.

|           |             |             |             |             |             |
|:---------:|:-----------:|:-----------:|:-----------:|:-----------:|:-----------:|
| Estrada 1 | 12:07:00 AM | 12:58:00 AM | 01:24:00 AM | 01:35:00 AM | 02:05:00 AM |
|           | 03:14:00 AM | 03:25:00 AM | 03:46:00 AM | 05:44:00 AM | 05:56:00 AM |
|           | 06:36:00 AM | 07:26:00 AM | 07:48:00 AM | 09:13:00 AM | 12:05:00 PM |
|           | 12:48:00 PM | 01:21:00 PM | 02:22:00 PM | 05:30:00 PM | 06:00:00 PM |
|           | 07:53:00 PM | 09:15:00 PM | 09:49:00 PM | 09:59:00 PM | 10:53:00 PM |
|           | 11:27:00 PM | 11:49:00 PM | 11:57:00 PM |             |             |
| Estrada 2 | 12:03:00 AM | 01:18:00 AM | 04:35:00 AM | 06:13:00 AM | 06:59:00 AM |
|           | 08:03:00 AM | 10:07:00 AM | 12:24:00 PM | 01:45:00 PM | 02:07:00 PM |
|           | 03:23:00 PM | 06:34:00 PM | 07:19:00 PM | 09:44:00 PM | 10:27:00 PM |
|           | 10:52:00 PM | 11:19:00 PM | 11:29:00 PM | 11:44:00 PM |             |
: **Tabela 3.13:** Horários das chamadas de auxílio em duas estradas num dia específico

a) Construa um histograma para a distribuição de frequências dos instantes de chamados em cada uma das estradas. 
b) Calcule os intervalos de tempo entre as sucessivas chamadas e descreva-os, para cada uma das estradas, utilizando medidas resumo e gráficos do tipo *boxplot*. Existe alguma relação entre o tipo de estrada e o intervalo de tempo entre as chamadas?
c) Por intermédio de um gráfico do tipo QQ, verifique se a distribuição da variável `Intervalo de tempo entre as chamadas` em cada estrada é compatível com um modelo normal. Faça o mesmo para um modelo exponencial. Compare as distribuições de frequências correspondentes às duas estradas.
:::

:::{.solution}
Em primeiro lugar, precisamos arrumar os dados em um formato mais tangível.

```{r}
chamadas <- tribble(
  ~estrada, ~horario,
  "Estrada 1", "00:07:00 AM", 
  "Estrada 1", "00:58:00 AM", 
  "Estrada 1", "01:24:00 AM", 
  "Estrada 1", "01:35:00 AM", 
  "Estrada 1", "02:05:00 AM", 
  "Estrada 1", "03:14:00 AM", 
  "Estrada 1", "03:25:00 AM", 
  "Estrada 1", "03:46:00 AM",
  "Estrada 1", "05:44:00 AM", 
  "Estrada 1", "05:56:00 AM", 
  "Estrada 1", "06:36:00 AM",
  "Estrada 1", "07:26:00 AM",
  "Estrada 1", "07:48:00 AM",
  "Estrada 1", "09:13:00 AM",
  "Estrada 1", "12:05:00 PM",
  "Estrada 1", "12:48:00 PM",
  "Estrada 1", "01:21:00 PM",
  "Estrada 1", "02:22:00 PM",
  "Estrada 1", "05:30:00 PM",
  "Estrada 1", "06:00:00 PM", 
  "Estrada 1", "07:53:00 PM", 
  "Estrada 1", "09:15:00 PM", 
  "Estrada 1", "09:49:00 PM", 
  "Estrada 1", "09:59:00 PM", 
  "Estrada 1", "10:53:00 PM", 
  "Estrada 1", "11:27:00 PM", 
  "Estrada 1", "11:49:00 PM", 
  "Estrada 1", "11:57:00 PM",
  "Estrada 2", "00:03:00 AM",
  "Estrada 2", "01:18:00 AM",
  "Estrada 2", "04:35:00 AM",
  "Estrada 2", "06:13:00 AM",
  "Estrada 2", "06:59:00 AM", 
  "Estrada 2", "08:03:00 AM",
  "Estrada 2", "10:07:00 AM",
  "Estrada 2", "12:24:00 PM",
  "Estrada 2", "01:45:00 PM",
  "Estrada 2", "02:07:00 PM", 
  "Estrada 2", "03:23:00 PM", 
  "Estrada 2", "06:34:00 PM", 
  "Estrada 2", "07:19:00 PM", 
  "Estrada 2", "09:44:00 PM", 
  "Estrada 2", "10:27:00 PM", 
  "Estrada 2", "10:52:00 PM",
  "Estrada 2", "11:19:00 PM",
  "Estrada 2", "11:29:00 PM",
  "Estrada 2", "11:44:00 PM"
) %>%
  mutate(
    horario = parse_time(horario)
  )
```

#### Distribuição de frequência {-}

```{r}
chamadas %>%
  ggplot(aes(horario)) +
    geom_histogram(
      bins = 12,
      fill = "grey",
      color = "grey30"
    ) +
    facet_wrap(~ estrada) +
    labs(
      title = bquote(bold("Figura 3.70:")~"Horário das chamadas de apoio"),
      x = "Horário",
      y = "Frequência observada"
    ) +
    tema
```

#### Intervalo entre as chamadas {-}

Primeiro precisamos calcular a diferença de tempo entre as chamadas. Para isso vamos adicionar uma coluna em nosso conjunto de dados contendo o horário da chamada anterior e outra contendo a diferença.

```{r}
chamadas$anterior = parse_time("00:00:00 AM")

n_1 <- chamadas %>% 
          filter(estrada == "Estrada 1") %>%
          nrow()

n_2 <- chamadas %>% 
          filter(estrada == "Estrada 2") %>%
          nrow()

for (i in 2:n_1) {
  chamadas$anterior[i] <- chamadas$horario[i-1]
}

for (i in 2:n_2) {
  chamadas$anterior[i + n_1] <- chamadas$horario[i + n_1 -1]
}

chamadas$intervalo <- as.duration(chamadas$horario - chamadas$anterior)
```

A tabela a seguir mostra o resultado desses cálculos.

```{r}
chamadas %>% 
  kable(
    format = "pipe",
    caption = "**Tabela 3.14:** Chamadas de auxílio em duas estradas",
    label = NA,
    digits = 2,
    align = "c",
    format.args = list(decimal.mark = ",")
  )
```

Com essas informações em mãos, podemos calcular as medidas de resumo para cada uma das estradas.

```{r}
summ_data <- function(data) {
  x <- data$intervalo
  
  tibble(
     n = sum(!is.na(x), na.rm = TRUE),
    `Mínimo` = as.duration(min(x, na.rm = TRUE)),
    Q1 = as.duration(quantile(x, 0.25, na.rm = TRUE)[[1]]),
    `Mediana` = as.duration(median(x, na.rm = TRUE)),
    Q3 = as.duration(quantile(x, 0.75, na.rm = TRUE)[[1]]),
    `Máximo` = as.duration(max(x, na.rm = TRUE)),
    `Média` = as.duration(mean(x, na.rm = TRUE)),
    `Desvio Padrão` = as.duration(sd(x, na.rm = TRUE)),
    `Distância Interquartil` = as.duration(IQR(x, na.rm = TRUE))
  )
}

chamadas %>%
  group_by(estrada) %>%
  nest() %>%
  mutate(
    resumo = map(data, summ_data),
  ) %>%
  select(-data) %>%
  unnest(resumo) %>%
  t() %>%
  kable(
    format = "pipe",
    caption = "**Tabela 3.15:** Resumo do intervalo entre chamadas para as duas estradas",
    label = NA,
    digits = 2,
    align = "c",
    format.args = list(decimal.mark = ",")
  )
```

O gráfico a seguir mostra a distribuição do intervalo entre chamadas:

```{r}
chamadas %>%
  ggplot(aes(x = estrada, y = intervalo)) +
    stat_boxplot(
      geom = "errorbar",
      width = 0.2
    ) +
    geom_boxplot(
      fill = "grey",
      color = "grey30"
    ) +
    labs(
      title = bquote(bold("Figura 3.71:")~"Distribuição dos intervalos entre as chamadas"),
      x = "",
      y = "Intervalo (s)"
    ) +
    tema
```
#### O intervalo entre as chamadas segue alguma tendência normal ou exponencial? {-}

Vamos começar plotando o histograma dos intervalos de tempo:

```{r}
chamadas %>%
  ggplot(aes(intervalo)) +
    geom_histogram(
      binwidth = 900,
      fill = "grey",
      color = "grey30"
    ) +
    facet_wrap(~ estrada) +
    labs(
      title = bquote(bold("Figura 3.72:")~"Intervalo de tempo entre as chamadas"),
      x = "Intervalo (s)",
      y = "Frequência"
    ) +
    tema
```

Este gráfico não nos indica nenhuma tendência, vamos então construir o gráfico QQ para cada uma das estradas, primeiro comparando com a distribuição normal:

```{r}
chamadas %>%
  ggplot(aes(sample = intervalo)) +
    geom_qq() +
    geom_qq_line() +
    facet_wrap(~ estrada) +
    labs(
      title = bquote(bold("Figura 3.73:")~"Intervalo de tempo entre as chamadas"),
      x = "Quantis normais",
      y = "Quantis amostrais"
    ) +
    tema
```

Como os dados estão muito afastados da reta de referência, não podemos dizer que os seguem a distribuição normal. Vamos tentar agora compará-los a uma distribuição exponencial.

```{r}
chamadas %>%
  ggplot(aes(sample = intervalo)) +
    geom_qq(
      distribution = stats::qexp
    ) +
    geom_qq_line(
      distribution = stats::qexp
    ) +
    facet_wrap(~ estrada) +
    labs(
      title = bquote(bold("Figura 3.74:")~"Intervalo de tempo entre as chamadas"),
      x = "Quantis exponenciais",
      y = "Quantis amostrais"
    ) +
    tema
```

Notamos que os dados estão muito mais próximos da distribuição exponencial, exceto por alguns pontos extremos.

:::

### Exercício 3.16 {- #exr3-16}

::: {.enunciado}
As notas finais de um curso de Estatistica foram: 7, 5, 4, 5, 6, 3, 8, 4, 5, 4, 6, 4, 5, 6, 4, 6, 6, 3, 8, 4, 5, 4, 5, 5 e 6.

a) Calcule a mediana, os quartis e a média.
b) Separe o conjunto de dados em dois grupos denominados **aprovados**, com nota pelo menos igual a 5, e **reprovados**, com notas menores do que 5. Compare a variáncia das notas desses dois grupos.
:::

:::{.solution}

Vamos organizar as notas em um data frame e incluir o status (Aprovado ou Reprovado) aos estudantes.

```{r}
estatistica <- tibble(
                  nota = c(7, 5, 4, 5, 6, 3, 8, 4, 5, 4, 6, 4, 5, 6, 4, 6, 6, 3, 8, 4, 5, 4, 5, 5, 6)
              ) %>%
              mutate(
                status = ifelse(nota < 5, "Reprovado", "Aprovado")
              )

head(estatistica)
```

Agora podemos calcular as medidas de resumo: 

```{r}
estatistica$nota %>%
  summ() %>%
  kable(
    format = "pipe",
    caption = "**Tabela 3.16:** Medidas de resumo para as notas em estatística",
    label = NA,
    digits = 2,
    align = "c",
    format.args = list(decimal.mark = ",")
  )
```

Vamos agora comparar os grupos:

```{r}
apr <- estatistica %>% filter(status == "Aprovado")
rep <- estatistica %>% filter(status == "Reprovado")
```

A tabela a seguir mostra um resumo dos aprovados:

```{r}
apr$nota %>%
  summ() %>%
  kable(
    format = "pipe",
    caption = "**Tabela 3.17:** Medidas de resumo para as notas dos aprovados em estatística",
    label = NA,
    digits = 2,
    align = "c",
    format.args = list(decimal.mark = ",")
  )
```

E a próxima tabela exibe um resumo para os reprovados:

```{r}
rep$nota %>%
  summ() %>%
  kable(
    format = "pipe",
    caption = "**Tabela 3.18:** Medidas de resumo para as notas dos reprovados em estatística",
    label = NA,
    digits = 2,
    align = "c",
    format.args = list(decimal.mark = ",")
  )
```

Avaliando o desvio padrão, e o intervalo interquartil, percebemos que as notas dos reprovados são muito mais uniformes, isto é, apresentam menor variação. O mesmo pode ser constatado no gráfico a seguir.

```{r}
estatistica %>%
  ggplot(aes(x = status, y = nota)) +
    stat_boxplot(
      geom = "errorbar",
      width = 0.2
    ) +
    geom_boxplot(
      fill = "grey",
      color = "grey30"
    ) +
    labs(
      title = bquote(bold("Figura 3.75:")~"Distribuição das notas em Estatística"),
      x = "Resultado Final",
      y = "Nota"
    ) +
    tema
```

:::

### Exercício 3.17 {- #exr3-17}

::: {.enunciado}
Considere o seguinte resumo descritivo da pulsação de estudantes com atividade fisica intensa e fraca:

Atividade | N   | Media | Mediana | DP   | Min | Max | Q1  | Q3
:---------|:---:|:-----:|:-------:|:----:|:---:|:---:|:---:|:---:
Intensa   | 30  | 79,6  | 82      | 10,5 | 62  | 90  | 70  | 85
Fraca	    | 30  | 73,1  | 70      | 9,6  | 58  | 92  | 63  | 77
: **Tabela 3.19:** Pulsação de estudantes durante atividade física

Indique se as seguintes afirmações estão corretas, justificando a sua respostas:

a) 5% e 50% dos estudantes com atividade fisica intensa e fraca, respectivamente, tiveram pulsação inferior a 70. 
b) A proporção de estudantes com fraca atividade fisica com pulsação inferior a 63 é menor que a proporção de estudantes com atividade fisica intensa com pulsação inferior a 70. 
c) A atividade fisica não tem efeito na média da pulsação dos estudantes. 
d) Mais da metade dos estudantes com atividade fisica intensa têm pulsação maior que 82.
:::

:::{.solution}
#### Item a {-}

A tabela nos informa que o primeiro quartil entre o grupo que praticou atividade intensa é 70, logo, espera-se que 25% dos estudantes neste grupo tiveram pulsação inferior a 70 e não 5% como alegado no enunciado. 
Entre os estudantes que particaram atividade fraca, como a mediana é 70, espera-se que pelo menos a metade tenha pulsação menor do que 70 (note contudo, que podem haver mais o que 50% dos estudantes!).

**Conclusão:** o item é FALSO.

#### Item b {-}

Considerando que o primeiro quartil vale 70 para o grupo de estudantes com atividade intensa e 63 para o grupo com atividade fraca, sabemos que pelo menos 25% dois estudantes de cada grupo estão abaixo desses valores.

**Conclusão:** a afirmação é FALSA.

#### item c {-}

Considerando a o intervalo de confiança para a média como $[\bar{x} - s; \bar{x} + s]$, temos que a verdadeira média para o grupo com atividade intensa está entre 69,1 e 90,1 e, para o segundo grupo, entre 63,5 e 82,7. Como os intervalos não são disjuntos, não é possível afirmar que há diferença entre as médias. 

**Conclusão:** a afirmativa é VERDADEIRA.

#### item d {-}

Como a mediana é 82, só podemos concluir que pelo menos metade dos estudantes tem pulsação maior do que ou igual a 82.

**Conclusão:** o item é FALSO.

:::

### Exercício 3.18 {- #exr3-18}

::: {.enunciado}
Considere os gráficos *boxplot* da Figura 3.34. Quais deles correspondem às pulsações dos estudantes submetidos a atividade física intensa e fraca?

a) A e B
b) B e D
c) A e C
d) B e C
:::

:::{.solution}
Analisando o gráfico, a correspondencia mais adequada seria A e D, que não está listada acima. 
:::

### Exercício 3.19 {- #exr3-19}

::: {.enunciado}
Os histogramas apresentados na Figura 3.35 mostram a distribuição das temperaturas (°C) ao longo de vários dias de investigação para duas regiões (R1 e R2). Indique se as afirmações abaixo estão corretas, justificando as respostas:

a) As temperaturas das regiões R1 e R2 têm mesma média e mesma variância.
b) Não é possível comparar as variâncias.
c) A temperatura média da região R2 é maior que a de R1.
d) As temperaturas das regiões R1 e R2 têm mesma média e variância diferentes.
:::

:::{.solution}
Vamos iniciar a análise considerando o ponto médio e a frequência das classes:

```{r}
r1 <- c(10,10,10,10,10,10,12,12,12,12,14,16,16,16,16,18,18,18,18,18,18)
r2 <- c(10,10,10,10,12,12,12,12,14,14,14,14,14,16,16,16,16,18,18,18,18)

mean(r1)
sd(r1)
mean(r2)
sd(r2)
```
#### Item a {-}

Temos a mesma média (14ºC), porém desvios padrão diferentes (3,35 para R1 e 2,83 para R2).

**Conclusão:** A afirmação é FALSA.

#### Item b {-}

Podemos calcular o desvio padrão considerando o ponto médio e as frequências das classes.

**Conclusão:** A afirmativa é falsa.

#### Item c {-}

Conforme calculamos acima, as médias são iguais.

**Conclusão:** A afirmativa é falsa.

#### Item d {-}

Conforme calculamos acima, as medias são iguais, mas os desvios são diferentes.

**Conclusão:** A afirmação é VERDADEIRA.
:::

### Exercício 3.20 {- #exr3-20}

::: {.enunciado}
Na companhia A, a média dos salários é 10000 unidades e o 3 quartil é 5000. Responda as seguintes perguntas, justificando a sua respostas:

a) Se você se apresentasse como candidato a funcionário nessa firma e se o seu salário fosse escolhido ao acaso entre todos os possíveis salários, o que seria mais provável: ganhar mais ou menos que 5000 unidades?
b) Suponha que na companhia B a média dos salários seja 7000 unidades, a variância praticamente zero e o salário também seja escolhido ao acaso. Em qual companhia você se apresentaria para procurar emprego, com base somente no salário?
:::

:::{.solution}
#### Item a {-}

Como o terceiro quartil é maior do que ou igual a 75% dos valores, a probabilidade de ganhar menos do que 5000 é de, pelo menos 75%. Logo é mais provável que o salário não ultrapasse este valor.

#### Item b {-}

Para melhor exemplificar, vamos simular uma distribuição com média 7000 e desvio padrão igual a 1/1000.

```{r}
salario <- tibble(
  x = rnorm(1000, mean = 7000, sd = 1/1000)
)

salario %>%
  ggplot(aes(x = x)) +
    geom_histogram(
      fill = "grey",
      color = "grey30"
    ) +
    labs(
      title = bquote(bold("Figura 3.76:")~"Distribuição dos salários na empresa B"),
      x = "Salário",
      y = "Frequência"
    ) +
    tema
```

Como a dispersão é muito pequena, os valores estão super concentrados ao redor da média, neste caso, a probabilidade de o salário ser menor do que 5000 é quase nula, tornando a emprea B mais atrativa.

:::

### Exercício 3.21 {- #exr3-21}

::: {.enunciado}
Num conjunto de dados, o primeiro quartil é 10, a mediana é 15 e o terceiro quartil é 20. Indique quais das seguintes afirmativas são verdadeiras, justificando sua resposta:

a) A distância interquartis é 5.
b) O valor 32 seria considerado outlier segundo o critério utilizado na construção do boxplot.
c) A mediana ficaria alterada de 2 unidades se um ponto com valor acima do terceiro quartil fosse substituído por outro 2 vezes maior. 
d) O valor mínimo é maior do que zero.
:::

:::{.solution}
x
:::

### Exercício 3.22 {- #exr3-22}

::: {.enunciado}
A bula de um medicamento A para dor de cabeça afirma que o tempo médio para que a droga faça efeito é de 60 seg com desvio padrão de 10 seg. A bula de um segundo medicamento B afirma que a média correspondente é de 60 seg com desvio padrão de 30 seg. Sabe-se que as distribuições são simétricas. Indique quais das seguintes afirmativas são verdadeiras, justificando sua resposta:

a) Os medicamentos são totalmente equivalentes com relação ao tempo para efeito pois as médias são iguais. 
b) Com o medicamento A, a probabilidade de cura de sua dor de cabeça antes de 40 seg é maior do que com o medicamento B. 
c) Com o medicamento B, a probabilidade de você ter sua dor de cabeça curada antes de 60 seg é maior que com o medicamento A. 
:::

:::{.solution}
x
:::

### Exercício 3.23 {- #exr3-23}

::: {.enunciado}
A tabela abaixo representa a distribuição do número de dependentes por empregado de uma determinada empresa.

Dependentes | Frequência
:----------:|:-----------:
1           | 40
2           | 50
3           | 30
4           | 20
5           | 10
Total       | 150

A mediana, média e moda cujos valores calculados por quatro estagiários, foram: 

a) 50; 15; 50 
b) 1; 2,1; 1 
c) 50,5; 50; 50 
d) 1; 1; 1

Indique qual deles está correto, justificando sua resposta.
:::

:::{.solution}
x
:::

### Exercício 3.24 {- #exr3-24}

::: {.enunciado}
Com relação ao [Exercício 23](#exr3-23), qual a porcentagem de empregados da empresa com 2 ou mais dependentes?

a) 40,1%
b) 50,1%
c) 60,3%
d) 73,3%
:::

:::{.solution}
x
:::

### Exercício 3.25 {- #exr3-25}

::: {.enunciado}
Num estudo na área de Oncologia, o número de vasos que alimentam o tumor está resumido na seguinte tabela.

Número de vasos | Frequência
:--------------:|:----------:
$0 \vdash 5$    | 8 (12%)
$5 \vdash 10$   | 23 (35%)
$10 \vdash 15$  | 12 (18%)
$15 \vdash 20$  | 9 (14%)
$20 \vdash 25$  | 8 (12%)
$25 \vdash 30$  | 6 (9%)
Total           | 66 (100%)

Indique a resposta correta.

a) O primeiro quartil é 25%. 
b) A mediana está entre 10 e 15.
c) O percentil de ordem 10% é 10.
d) A distância interquartis é 50.
e) Nenhuma das respostas anteriores.
:::

:::{.solution}
x
:::

### Exercício 3.26 {- #exr3-26}

::: {.enunciado}
Utilizando o mesmo enunciado da questão anterior, indique a resposta correta: 

a) Não é possível estimar nem a média nem a variância com esses dados.
b) A variancia é menor que 30.
c) A média estimada é 12,8. 
d) Em apenas 35% dos casos, o número de vasos é maior que 10.
e) Nenhuma das anteriores.
:::

:::{.solution}
x
:::

### Exercício 3.27 {- #exr3-27}

::: {.enunciado}
Em dois estudos realizados com o objetivo de estimar o nivel médio de colesterol total para uma população de indivíduos saudáveis observaram-se os dados indicados na tabela seguinte:

Estudo | n   | Média     | Desvio padrão
:-----:|:---:|:---------:|:-------------:
A      | 100 | 160 mg/dL | 60 mg/dL
B      | 49  | 150 mg/dL | 35 mg/dL
: **Tabela A:** Medidas descritivas dos estudos A e B

Indique a resposta correta:

a) Não é possível estimar o nível médio de colesterol populacional só com esses dados.
b) Se os dois estudos foram realizados com amostras da mesma população não deveria haver diferença entre os desvios padrões amostrais.
c) Com os dados do estudo B, o colesterol médio populacional pode ser estimado com mais precisão do que com os dados do estudo A.
d) Ambos os estudos sugerem que a distribuição do colesterol na população é simétrica.
e) Nenhuma das respostas anteriores.
:::

:::{.solution}
x
:::

### Exercício 3.28 {- #exr3-28}

::: {.enunciado}
Considere um conjunto de dados $\{X_{1}, \cdots , X_{n}\}$

a) Obtenha a média e a variancia de $W_{1}, \cdots , W_{n}$ em que $W_{l} = X_{l} + k$ com $k$ denotando uma constante, em termos da média e da variancia de $X$. 
b) Calcule a média e a variância de $v_{1}, \cdots , V_{n}$ em que $V_{i} = kX_{i}$ com $k$ denotando uma constante, em termos da média e da variancia de $X$.
:::

:::{.solution}
x
:::

### Exercício 3.29 {- #exr3-29}

::: {.enunciado}
Prove que $S^{2}$ dado por (3.10) é um estimador não enviesado da variáncia populacional.
:::

:::{.solution}
x
:::

### Exercício 3.30 {- #exr3-30}

::: {.enunciado}
Considere os valores $X_{1}, \cdots , X_{n}$ de uma variável $X$, com média $\overline{X}$ e desvio padrão $S$. Mostre que a variável $Z$, cujos valores são $Z_{i} = (X_{i} - X) / S, \ i = 1, \cdots , n$, tem média 0 e desvio padrão 1.
:::

:::{.solution}
x
:::

### Exercício 3.31 {- #exr3-31}

::: {.enunciado}
Prove a relação (3.8). Como ficaria essa expressão para $S^{2}$?
:::

:::{.solution}
x
:::

### Exercício 3.32 {- #exr3-32}

::: {.enunciado}
Considere uma amostra aleatória simples $X_{1}, \cdots , X_{n}$ de uma variável $X$ que assume o valor 1 com probabilidade $0 < p < 1$ e o valor 0 com probabilidade $1 - p$. Seja $\hat{p} = n^{-1} \sum_{i=1}^{n} X_{i}$. Mostre que:

i) $E(X_{i}) = p$ e $Var(X_{i}) = p (1 - p)$.
ii) $E(\hat{p}) = p$ e $Var(\hat{p}) = p (1 - p) / n$.
iii) $0 < Var(X_{i}) < 0,25$.

Com base nesses resultados, utilize o Teorema Limite Central [ver Sen et al. (2009), por exemplo] para construir um intervalo de confiança aproximado conservador (ie, com a maior amplitude possível) para $p$. Utilize o Teorema de Sverdrup [ver Sen et al. (2009), por exemplo] para construir um intervalo de confiança aproximado para $p$ com amplitude menor que a do intervalo mencionado acima. Veja também, Bussab e Morettin (2017).
:::

:::{.solution}
x
:::

### Exercício 3.33 {- #exr3-33}

::: {.enunciado}
Com a finalidade de entender a diferença entre "desvio padrão" e "erro padrão",

a) Simule 10000 dados de uma distribuição normal com média 12 e desvio padrão 4. Construa o histograma correspondente, calcule a média e o desvio padrão amostrais e compare os valores obtidos com aqueles utilizados na geração dos dados.
b) Simule 500 amostras de tamanhon $n = 4$ dessa população. Calcule a média amostral de cada amostra, construa o histograma dessas médias e estime o correspondente desvio padrão (que é o erro padrão da média).
c) Repita os passos a) e b) com amostras de tamanhos $n = 9$ e $n = 100$. Comente os resultados comparando-os com aqueles preconizados pela teoria.
d) Repita os passos a) - c) simulando amostras de uma distribuição qui-quadrado com 3 graus de liberdade.
:::

:::{.solution}
x
:::